<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rails Posts | btihen</title>
    <link>https://btihen.me/post_ruby_rails/</link>
      <atom:link href="https://btihen.me/post_ruby_rails/index.xml" rel="self" type="application/rss+xml" />
    <description>Rails Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2021</copyright><lastBuildDate>Thu, 25 Feb 2021 18:57:00 +0200</lastBuildDate>
    <image>
      <url>https://btihen.me/img/btihen_landing_page.png</url>
      <title>Rails Posts</title>
      <link>https://btihen.me/post_ruby_rails/</link>
    </image>
    
    <item>
      <title>Tweets - A Standard Rails Single Page App</title>
      <link>https://btihen.me/post_ruby_rails/rails_tweet_standard_rails/</link>
      <pubDate>Thu, 25 Feb 2021 18:57:00 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/rails_tweet_standard_rails/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This article is just to have a base app that stays on the index page.  We will use this as a starting point for a more efficient single page app by updating this project with Hotwire (in the next article)&lt;/p&gt;
&lt;p&gt;(Hotwire)[https://hotwire.dev/] allows us to build Single Page Apps using Ruby and Rails with nearly NO configuration! It allow very responsive web-applications as it reloads only the parts of the page that change via a socket.  Hotwire using (Turbo)[https://turbo.hotwire.dev/] - an evolution of TurboLinks and as such is mobile friendly and in most cases can send the replacement HTML directly from the server to the client with minimal or no client side processing over websockets so there is minimal lag time.&lt;/p&gt;
&lt;p&gt;This code can be found at: &lt;a href=&#34;https://github.com/btihen/tweet_simulator_rails&#34;&gt;https://github.com/btihen/tweet_simulator_rails&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;basic-setup&#34;&gt;Basic Setup&lt;/h2&gt;
&lt;h3 id=&#34;create-the-project&#34;&gt;Create the project&lt;/h3&gt;
&lt;p&gt;We&amp;rsquo;ll skip Turbolinks since Turbo replaces Turbolinks and also installs Stimulus&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails new tweets -d postgresql -T --skip-turbolinks --skip-spring
cd tweets
git add .
git commit -m &amp;quot;initial commit after creation&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I generally take a lot of git snapshots (and then squash them - so its easy to go back to a known good point if things don&amp;rsquo;t work out).&lt;/p&gt;
&lt;h3 id=&#34;create-a-traditional-rails-tweet-clone&#34;&gt;Create a Traditional Rails Tweet Clone&lt;/h3&gt;
&lt;h4 id=&#34;tweet-model&#34;&gt;Tweet Model&lt;/h4&gt;
&lt;p&gt;We&amp;rsquo;ll scaffold the model to get all the parts we need&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/rails g scaffold tweet body:text likes:integer retweets:integer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We&amp;rsquo;ll update the migration to prevent blanks - make the migration file look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# db/migrate/yyyymmddHHMMSS_create_tweets.rb
class CreateTweets &amp;lt; ActiveRecord::Migration[6.1]
  def change
    create_table :tweets do |t|
      t.text :body, null: false
      t.integer :likes, null: false, default: 0
      t.integer :retweets, null: false, default: 0

      t.timestamps
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we should be able to successfully create and migrate out database&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/rails db:create
bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given the Database restrictions we&amp;rsquo;ll add validations to the model. So now it should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/models/tweet.rb
class Tweet &amp;lt; ApplicationRecord
  validates :body, presence: true
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets also point the root route at our tweets resource - so now it should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config/routes.rb
Rails.application.routes.draw do
  resources :tweets
  root to: &amp;quot;tweets#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets start up rails and be sure everything works so far:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/rails s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go to &lt;code&gt;http://localhost:3000&lt;/code&gt; and make and edit and delete some tweets.&lt;/p&gt;
&lt;p&gt;Assuming it works lets commit these changes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;created tweet scaffold, validations and routes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;lets-make-this-useable-more-like-a-single-page-app&#34;&gt;Let&amp;rsquo;s make this useable (more like a single page app)&lt;/h4&gt;
&lt;p&gt;Lets start by fixing the following problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the create form allows us to choose and edit likes and retweets&lt;/li&gt;
&lt;li&gt;tweets are listed in the opposite order in oldest to newest&lt;/li&gt;
&lt;li&gt;to create a new tweet we need to go to a separate new page&lt;/li&gt;
&lt;li&gt;creating and editing new tweets brings us to a show page (away from our index)&lt;/li&gt;
&lt;li&gt;message, likes, retweets, etc are all listed in one long table row (we&amp;rsquo;ll fix with some bootstrap css)&lt;/li&gt;
&lt;li&gt;likes and retweets are not usable&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As mentioned users shouldn&amp;rsquo;t choose their likes and retweets:
&lt;img src=&#34;tweet_form_1st.png&#34; alt=&#34;tweet_form_1st&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now lets remove likes and retweets from our form:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/views/tweets/_form.html.erb
&amp;lt;%= form_with(model: tweet) do |form| %&amp;gt;
  &amp;lt;% if tweet.errors.any? %&amp;gt;
    &amp;lt;div id=&amp;quot;error_explanation&amp;quot;&amp;gt;
      &amp;lt;h2&amp;gt;&amp;lt;%= pluralize(tweet.errors.count, &amp;quot;error&amp;quot;) %&amp;gt; prohibited this tweet from being saved:&amp;lt;/h2&amp;gt;

      &amp;lt;ul&amp;gt;
        &amp;lt;% tweet.errors.each do |error| %&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= error.full_message %&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;% end %&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;% end %&amp;gt;

  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;%= form.label :body %&amp;gt;
    &amp;lt;%= form.text_area :body %&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;actions&amp;quot;&amp;gt;
    &amp;lt;%= form.submit %&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the form should look like:
&lt;img src=&#34;tweet_form_2nd.png&#34; alt=&#34;tweet_form_2nd&#34;&gt;&lt;/p&gt;
&lt;p&gt;If you made several tweets you&amp;rsquo;ll notice that the tweets are in oldest to newest.
&lt;img src=&#34;tweet_index_1st_oldest.png&#34; alt=&#34;tweet_index_1st&#34;&gt;&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll fix that with the index controller sort order:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/controllers/tweets_controller.rb
class TweetsController &amp;lt; ApplicationController
  before_action :set_tweet, only: %i[ show edit update destroy ]

  def index
    @tweets = Tweet.all.order(created_at: :desc)
  end
  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;tweet_index_2nd_newest.png&#34; alt=&#34;tweet_index_2nd&#34;&gt;&lt;/p&gt;
&lt;p&gt;now tweets should be newest to oldest&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s put our create tweet at the top of our index page&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/views/tweets/index.html.erb
&amp;lt;p id=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;Tweets&amp;lt;/h1&amp;gt;

&amp;lt;h4&amp;gt;New Tweet&amp;lt;/h4&amp;gt;
&amp;lt;%= render &amp;quot;tweets/form&amp;quot;, tweet: @tweet %&amp;gt;

&amp;lt;h4&amp;gt;Tweet Feed&amp;lt;/h4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now when we check out index page again &amp;ndash; oops, we get an error:
&lt;img src=&#34;tweet_index_3rd_error.png&#34; alt=&#34;tweet_index_3rd_error&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;errors&lt;/code&gt; is null because the new instance isn&amp;rsquo;t available we need to add a new tweet to our index page from the controller:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/controllers/tweets_controller.rb
class TweetsController &amp;lt; ApplicationController
  before_action :set_tweet, only: %i[ show edit update destroy ]

  def index
    # put newest tweets at the top of the page
    @tweets = Tweet.all.order(created_at: :desc)
    @tweet = Tweet.new
  end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when we view index we should be able to create a tweet on the index page:
&lt;img src=&#34;tweet_index_4th_top.png&#34; alt=&#34;tweet_index_4th&#34;&gt;&lt;/p&gt;
&lt;p&gt;However, after creation we still go to show page and need to navigate back to the index page - lets fix that in the create controller.  We will change the line:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format.html { redirect_to @tweet, notice: &amp;quot;Tweet was successfully created.&amp;quot; }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;with:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format.html { redirect_to tweets_url, notice: &amp;quot;Tweet was successfully created.&amp;quot; }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We will have the same problem with update &amp;ndash; so let&amp;rsquo;s fix them both.  Now the controller should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/controllers/tweets_controller.rb
  def create
    @tweet = Tweet.new(tweet_params)

    respond_to do |format|
      if @tweet.save
        format.html { redirect_to tweets_url, notice: &amp;quot;Tweet was successfully created.&amp;quot; }
        format.json { render :show, status: :created, location: @tweet }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @tweet.errors, status: :unprocessable_entity }
      end
    end
  end

  def update
    respond_to do |format|
      if @tweet.update(tweet_params)
        format.html { redirect_to tweet_url, notice: &amp;quot;Tweet was successfully updated.&amp;quot; }
        format.json { render :show, status: :ok, location: @tweet }
      else
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @tweet.errors, status: :unprocessable_entity }
      end
    end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now after we create a new tweet we should &amp;lsquo;stay&amp;rsquo; (it actually reloads - which could be slow if we had many tweets on the page - we will fix this with hotwire) on the index page and see:
&lt;img src=&#34;tweet_index_5th_after_create.png&#34; alt=&#34;tweet_index_5th&#34;&gt;&lt;/p&gt;
&lt;p&gt;OK we are almost there, but we still have rows of tables and not a nice tweet feed look.&lt;/p&gt;
&lt;p&gt;Lets add Bootstrap CSS for some modest beauty (you can copy this file or use the below link to get the newest Bootstrap CSS)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/views/layout/application.html.erb
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;Tweets&amp;lt;/title&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
  &amp;lt;%= csrf_meta_tags %&amp;gt;
  &amp;lt;%= csp_meta_tag %&amp;gt;

  &amp;lt;link rel=&amp;quot;stylesheet&amp;quot;
        href=&amp;quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css&amp;quot;
        integrity=&amp;quot;sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l&amp;quot;
        crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;
  &amp;lt;%= stylesheet_link_tag &#39;application&#39;, media: &#39;all&#39; %&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;%= yield %&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you can get the newest bootstrap link from: &lt;a href=&#34;https://getbootstrap.com/docs/&#34;&gt;https://getbootstrap.com/docs/&lt;/a&gt; or &lt;a href=&#34;https://www.bootstrapcdn.com/&#34;&gt;https://www.bootstrapcdn.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now lets make a partial reformat our feed with bootstrap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/views/tweets/_tweet.html.erb
&amp;lt;div class=&amp;quot;card card-body&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;&amp;lt;%= tweet.body %&amp;gt;&amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;mt-2&amp;quot;&amp;gt;
    &amp;lt;%= &amp;quot;Like (#{tweet.likes})&amp;quot; %&amp;gt;

    &amp;lt;%= &amp;quot;Retweet (#{tweet.retweets})&amp;quot; %&amp;gt;

    &amp;lt;%= link_to &#39;Edit&#39;, edit_tweet_path(tweet),
              class: &amp;quot;btn btn-sm btn-success&amp;quot; %&amp;gt;

    &amp;lt;%= link_to &#39;Destroy&#39;, tweet_path(tweet), method: :delete,
              data: { confirm: &#39;Are you sure?&#39; },
              class: &amp;quot;btn btn-sm btn-danger&amp;quot; %&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets integrate the tweet partial into the index page:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/views/tweets/index.html.erb
&amp;lt;p id=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;h1&amp;gt;Tweets&amp;lt;/h1&amp;gt;

&amp;lt;h4&amp;gt;New Tweet&amp;lt;/h4&amp;gt;
&amp;lt;%= render &amp;quot;tweets/form&amp;quot;, tweet: @tweet %&amp;gt;

&amp;lt;h4&amp;gt;Tweet Feed&amp;lt;/h4&amp;gt;
&amp;lt;%= render @tweets %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We now have an app that basically works from the index pages (not yet Edit, but without Hotwire, that&amp;rsquo;s difficult &amp;ndash; see the next article)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;tweet_index_6th_formatted.png&#34; alt=&#34;tweet_index_6th&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take another git snapshot of &amp;lsquo;index&amp;rsquo; reloading app.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;tweet app mostly from the index page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;activate-likes-and-retweets&#34;&gt;Activate likes and retweets&lt;/h4&gt;
&lt;p&gt;To finish this simple app lets activate Likes and Retweets - we will do this with new controllers since this is an independent action from our tweet itself.  We will use the &lt;code&gt;create&lt;/code&gt; since we are &lt;code&gt;creating&lt;/code&gt; a like or a retweet.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s build the like controller - we will redirect back to the index where we want to stay:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/controllers/likes_controller.rb
class LikesController &amp;lt; ApplicationController
  before_action :set_tweet

  def create
    @tweet.increment! :likes
    redirect_to tweets_url
  end

  private

  def set_tweet
    @tweet = Tweet.find(params[:tweet_id])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now the retweet controller:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/controllers/retweets_controller.rb
class RetweetsController &amp;lt; ApplicationController
  before_action :set_tweet

  def create
    @tweet.increment! :retweets
    redirect_to tweets_url
  end

  private

  def set_tweet
    @tweet = Tweet.find(params[:tweet_id])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These controllers are dependent on the tweet so they are subroutes of a tweet - so lets update our routes to be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config/routes.rb
Rails.application.routes.draw do
  resources :tweets do
    resource :like, only: [:create]
    resource :retweet, only: [:create]
  end
  root to: &amp;quot;tweets#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets add the connection to controller in our front-end with buttons.  Note we need to use the &lt;code&gt;method: :post&lt;/code&gt; for our like and retweet &lt;code&gt;create&lt;/code&gt; because these are normally &lt;code&gt;posted&lt;/code&gt; by the &lt;code&gt;edit&lt;/code&gt; form.  In this case we want to bypass a form and just update.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/views/tweets/_tweet.html.erb
&amp;lt;div class=&amp;quot;card card-body&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;&amp;lt;%= tweet.body %&amp;gt;&amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;mt-2&amp;quot;&amp;gt;
    &amp;lt;%= link_to &amp;quot;Like (#{tweet.likes})&amp;quot;,
                tweet_like_path(tweet),
                method: :post,
                class: &amp;quot;btn btn-sm btn-outline-success&amp;quot; %&amp;gt;

    &amp;lt;%= link_to &amp;quot;Retweet (#{tweet.retweets})&amp;quot;,
                tweet_retweet_path(tweet),
                method: :post,
                class: &amp;quot;btn btn-sm btn-outline-info&amp;quot; %&amp;gt;

    &amp;lt;%= link_to &#39;Edit&#39;, edit_tweet_path(tweet),
                class: &amp;quot;btn btn-sm btn-outline-primary&amp;quot; %&amp;gt;

    &amp;lt;%= link_to &#39;Destroy&#39;, tweet_path(tweet), method: :delete,
                data: { confirm: &#39;Are you sure?&#39; },
                class: &amp;quot;btn btn-sm btn-outline-danger&amp;quot; %&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Test that everything works as expected!  Assuming it works - we will take another snapshot.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;likes and retweets enabled and also &#39;stay&#39; on index page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;tweet_index_7th_likes_retweets.png&#34; alt=&#34;tweet_index_7th&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Install and Configure Rails</title>
      <link>https://btihen.me/post_ruby_rails/robust_rails_01_install_configure/</link>
      <pubDate>Thu, 10 Sep 2020 01:46:07 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/robust_rails_01_install_configure/</guid>
      <description>&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;
&lt;p&gt;To document is mostly for me &amp;ndash; at least until I automate my setup defaults. However, I am glad to share and get ideas from others too.  I will build a little calendar app I use with friends (it&amp;rsquo;s focused on being mobile friendly and easy to use &amp;ndash; not a full featured calendar).&lt;/p&gt;
&lt;h1 id=&#34;rails-setup&#34;&gt;Rails Setup&lt;/h1&gt;
&lt;p&gt;Taken from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/alxndr/7569551&#34;&gt;https://gist.github.com/alxndr/7569551&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codewithjason.com/rails-integration-tests-rspec-capybara/&#34;&gt;https://www.codewithjason.com/rails-integration-tests-rspec-capybara/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hackernoon.com/how-to-build-awesome-integration-tests-with-capybara-j9333y68&#34;&gt;https://hackernoon.com/how-to-build-awesome-integration-tests-with-capybara-j9333y68&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;create-the-project&#34;&gt;create the project:&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# -T - skips tests;              I like rspec
# -d postgresql;                 I like postgresql best for the db
# --skip-spring --skip-listen;   Spring caches and doesn&#39;t notice all changes (even after rails restart)
#                                I have lost several hours not realizing Spring wasn&#39;t seeing my changes

rails new calendar -T -d postgresql --webpack=stimulus --skip-spring --skip-listen

cd calendar

# in some cases you may have serveral bundlers or need to create binstubs
# gem install bundler:2.1.4
# rails app:update:bin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;update-the-readme-and-initialize-git&#34;&gt;update the README and initialize Git&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;intial commit&amp;quot;
git remote add origin git@gitlab.com:btihen/calendar.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;add-extra-gems-for-this-project&#34;&gt;Add extra Gems for this project&lt;/h2&gt;
&lt;p&gt;add rspec, devise, factory_bot and stimulus_reflex&lt;/p&gt;
&lt;p&gt;Execute the following command (or add to the Gemfile)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt; Gemfile
# Project Gems
##############

# FRONT END
###########
gem &amp;quot;stimulus_reflex&amp;quot;, &amp;quot;~&amp;gt; 3.3&amp;quot;

# BACK END
##########
gem &#39;devise&#39;

# DEV / TESTS
#############
group :development, :test do
  gem &#39;awesome_print&#39;        # formats pry (&amp;amp; irb outputs into readable formats)

  gem &#39;pry-rails&#39;
  gem &#39;pry-byebug&#39;           # Adds byebug&#39;s step debugging and stack navigation
  # gem &#39;pry-debugger&#39;       # adds step, continue, etc (alternative to pry-byebug)
  gem &#39;pry-stack_explorer&#39;   # easy stack traces when debugging
  # more pry gems if needed at: https://spin.atomicobject.com/2012/08/06/live-and-let-pry/

  gem &#39;factory_bot_rails&#39;
  gem &#39;faker&#39;

  # gem &#39;rspec-rails&#39;
  gem &#39;capybara&#39;
  gem &#39;rspec-rails&#39;, &#39;~&amp;gt; 4.0.0&#39;

  # lets spring work with rspec
  gem &#39;spring-commands-rspec&#39;
end

group :test do
  # easier tests (inside rspec)
  gem &#39;shoulda-matchers&#39;

  # cucumber can test emails (rspec too?)
  # gem &#39;email_spec&#39;

  # code coverage
  gem &#39;simplecov&#39;
  gem &#39;simplecov-console&#39;
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-uncomment-a-few-gems-in-the-original-gemfile&#34;&gt;Now uncomment a few Gems in the Original Gemfile&lt;/h2&gt;
&lt;p&gt;Uncomment the following to ensure ActionText and Stimulus Refelx (work properly).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gem &#39;image_processing&#39;, &#39;~&amp;gt; 1.2&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is needed by Active Storage (ActionText needs Active Storage)&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gem &#39;redis&#39;, &#39;~&amp;gt; 4.0&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is needed by Stimulus Reflex (which uses Action Channels) to manage WebSockets&lt;/p&gt;
&lt;h2 id=&#34;install-and-configure-base-gems&#34;&gt;Install and configure base gems&lt;/h2&gt;
&lt;p&gt;now run:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;to install all the new gems and create a &lt;code&gt;Gemfile.lock&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;javascipt-packages-to-support-new-gems&#34;&gt;JavaScipt packages to support new Gems.&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;yarn add cable_ready stimulus_reflex&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;now-installconfigure-stimulus-reflex&#34;&gt;Now Install/Configure Stimulus Reflex:&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bin/rails stimulus_reflex:install
# bin/rails dev:cache
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;install-activestorage-and-actiontext&#34;&gt;Install ActiveStorage and ActionText&lt;/h2&gt;
&lt;p&gt;run the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# bundle exec rails webpacker:install
# bundle exec rails webpacker:install:stimulus
bundle exec rails active_storage:install
bundle exec rails action_text:install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No configuration is needed for development (but is needed for production environments)&lt;/p&gt;
&lt;h2 id=&#34;rspec&#34;&gt;RSPEC&lt;/h2&gt;
&lt;h3 id=&#34;install-with&#34;&gt;Install with:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bin/rails g rspec:install&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;configure&#34;&gt;Configure:&lt;/h2&gt;
&lt;h3 id=&#34;create-needed-folders-for-our-config&#34;&gt;Create needed folders for our config&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;mkdir spec/features

# a place to put test helper code
mkdir spec/support
mkdir spec/support/features
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rspec-config-file-specrails_helperrb&#34;&gt;Rspec Config file &lt;code&gt;spec/rails_helper.rb&lt;/code&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;To enable integration tests with rspec add: &lt;code&gt;require &#39;capybara/rspec&#39;&lt;/code&gt; below &lt;code&gt;require &#39;rspec/rails&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;To load Test helper code add: &lt;code&gt;Dir[Rails.root.join(&amp;quot;spec/support/**/*.rb&amp;quot;)].each { |file| require file }&lt;/code&gt; below &lt;code&gt;require &#39;capybara/rspec&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;just after the ActiveRecord config and before RSpec.configure block add:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Capybara.register_driver :selenium_chrome do |app|
  Capybara::Selenium::Driver.new(app, browser: :chrome)
end
Capybara.javascript_driver = :selenium_chrome
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Add the FactoryBot config in the section with:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;RSpec.configure do |config|
  # ...

  # support for Factory Bot
  config.include FactoryBot::Syntax::Methods

  # setup devise login helpers in Rspec
  config.include Devise::Test::IntegrationHelpers, type: :request

  # allows us for force session logouts (im feature tests)
  config.include Warden::Test::Helpers
end
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;finally at the end of the file add support for shoulda matchers with:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Shoulda::Matchers.configure do |config|
  config.integrate do |with|
    with.test_framework :rspec
    with.library :rails
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOW &lt;code&gt;spec/rails_helper.rb&lt;/code&gt; should look like (its long, sometimes the full context is clearer):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This file is copied to spec/ when you run &#39;rails generate rspec:install&#39;
require &#39;spec_helper&#39;
ENV[&#39;RAILS_ENV&#39;] ||= &#39;test&#39;
require File.expand_path(&#39;../config/environment&#39;, __dir__)
# Prevent database truncation if the environment is production
abort(&amp;quot;The Rails environment is running in production mode!&amp;quot;) if Rails.env.production?
require &#39;rspec/rails&#39;
# Add additional requires below this line. Rails is not loaded until this point!

# enables integration/feature tests using rspec
require &#39;capybara/rspec&#39;

# loads custom helper test code
Dir[Rails.root.join(&amp;quot;spec/support/**/*.rb&amp;quot;)].each { |file| require file }
# or you could use:
# Dir[Rails.root.join(&#39;spec&#39;, &#39;support&#39;, &#39;**&#39;, &#39;*.rb&#39;)].sort.each { |f| require f }

# Checks for pending migrations and applies them before tests are run.
# If you are not using ActiveRecord, you can remove these lines.
begin
  ActiveRecord::Migration.maintain_test_schema!
rescue ActiveRecord::PendingMigrationError =&amp;gt; e
  puts e.to_s.strip
  exit 1
end

# configure capybara integration tests
Capybara.register_driver :selenium_chrome do |app|
  Capybara::Selenium::Driver.new(app, browser: :chrome)
end
Capybara.javascript_driver = :selenium_chrome

RSpec.configure do |config|
  # Remove this line if you&#39;re not using ActiveRecord or ActiveRecord fixtures
  config.fixture_path = &amp;quot;#{::Rails.root}/spec/fixtures&amp;quot;

  # If you&#39;re not using ActiveRecord, or you&#39;d prefer not to run each of your
  # examples within a transaction, remove the following line or assign false
  # instead of true.
  config.use_transactional_fixtures = true

  # You can uncomment this line to turn off ActiveRecord support entirely.
  # config.use_active_record = false

  # RSpec Rails can automatically mix in different behaviours to your tests
  # based on their file location, for example enabling you to call `get` and
  # `post` in specs under `spec/controllers`.
  #
  # You can disable this behaviour by removing the line below, and instead
  # explicitly tag your specs with their type, e.g.:
  #
  #     RSpec.describe UsersController, type: :controller do
  #       # ...
  #     end
  #
  # The different available types are documented in the features, such as in
  # https://relishapp.com/rspec/rspec-rails/docs
  config.infer_spec_type_from_file_location!

  # Filter lines from Rails gems in backtraces.
  config.filter_rails_from_backtrace!
  # arbitrary gems may also be filtered via:
  # config.filter_gems_from_backtrace(&amp;quot;gem name&amp;quot;)

  # support for Factory Bot
  config.include FactoryBot::Syntax::Methods

  # setup devise login helpers in Rspec (login helpers)
  config.include Devise::Test::IntegrationHelpers, type: :request

  # allows us for force session logouts (im feature tests)
  config.include Warden::Test::Helpers
end

Shoulda::Matchers.configure do |config|
  config.integrate do |with|
    with.test_framework :rspec
    with.library :rails
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;create--test-a-landing-page&#34;&gt;Create / Test a landing page&lt;/h1&gt;
&lt;p&gt;A simple config test before we setup devise (authentication).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Generate a page&lt;/strong&gt; &amp;ndash; I don&amp;rsquo;t (generally) use helpers nor contoller or view specs - so I&amp;rsquo;ll create the landing page using the following generator:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;rails g controller Landing index --no-helper --no-assets --no-controller-specs --no-view-specs
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Update Routes&lt;/strong&gt; &lt;code&gt;config/routes.rb&lt;/code&gt; with:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  get &#39;landing/index&#39;
  root to: &amp;quot;landing#index&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;Add Hidden Test Content&lt;/strong&gt; to simplify testing add:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Request test:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# spec/requests/landing_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Landings&amp;quot;, type: :request do

  describe &amp;quot;GET /index&amp;quot; do
    it &amp;quot;returns http success&amp;quot; do
      get &amp;quot;/landing/index&amp;quot;
      expect(response).to have_http_status(:success)

      expect(response.body).to include(&amp;quot;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Feature Test (to be sure they are working too)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# spec/features/landing_page_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Landing Page Works without a login&#39;, type: :feature do
  scenario &#39;Visit landing Page&#39; do
    visit root_path

    page_tag = find(&#39;p#landing_index&#39;, text: &#39;Landing Index&#39;, visible: false)
    expect(page_tag).to be_truthy
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Create DB and Test&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;bin/rails db:create
bin/rails db:migrate
bundle exec rspec
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;Assuming test run and are green - we can commit a functioning setup:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;rspec configured and working&amp;quot;
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you plan to user database_cleaner &amp;ndash; then also see this article to finish your config:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@amliving/my-rails-rspec-set-up-6451269847f9&#34;&gt;https://medium.com/@amliving/my-rails-rspec-set-up-6451269847f9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;a basic login feature test might look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  let(:user)  { FactoryBot.create :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user logs in successfully&#39; do
    scenario &#39;and is redirected to user home page&#39; do
      user_log_in(user)
      expect(current_path).to eql(auth_user_root_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Durable_rails_config</title>
      <link>https://btihen.me/post_ruby_rails/robust_rails_02_config/</link>
      <pubDate>Fri, 10 Jul 2020 20:46:07 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/robust_rails_02_config/</guid>
      <description>&lt;h1 id=&#34;rails-setup&#34;&gt;Rails Setup&lt;/h1&gt;
&lt;p&gt;Take from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/alxndr/7569551&#34;&gt;https://gist.github.com/alxndr/7569551&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codewithjason.com/rails-integration-tests-rspec-capybara/&#34;&gt;https://www.codewithjason.com/rails-integration-tests-rspec-capybara/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hackernoon.com/how-to-build-awesome-integration-tests-with-capybara-j9333y68&#34;&gt;https://hackernoon.com/how-to-build-awesome-integration-tests-with-capybara-j9333y68&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;create the project:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -T - skips tests - I like using rspec
# -d postgresql - I like using postgresql best for the db
# Spring &amp;amp; listen speed testing - but can get out of sync and make problems
rails new challenges -T -d postgresql --skip-spring --skip-listen

Excerpt From: David Bryant Copeland. “Sustainable Web Development with Ruby on Rails.” Apple Books. 
cd challenges
gem install bundler:2.1.4
rails app:update:bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update the readme with purpose, setup and running tests&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;intial commit&amp;quot;
git remote add origin git@gitlab.com:peakchallenges/challenges.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add rspec, devise &amp;amp; factory_bot to Gemfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt; Gemfile
# Container4 Gems
#################

# BACK END
##########
gem &#39;devise&#39;

# DEV / TESTS
#############
group :development, :test do
  gem &#39;awesome_print&#39;        # formats pry (&amp;amp; irb outputs into readable formats)

  gem &#39;pry-rails&#39;
  gem &#39;pry-byebug&#39;           # Adds byebug&#39;s step debugging and stack navigation
  # gem &#39;pry-debugger&#39;       # adds step, continue, etc (alternative to pry-byebug)
  gem &#39;pry-stack_explorer&#39;   # easy stack traces when debugging
  # more pry gems if needed at: https://spin.atomicobject.com/2012/08/06/live-and-let-pry/

  gem &#39;factory_bot_rails&#39;
  gem &#39;faker&#39;

  # gem &#39;rspec-rails&#39;
  gem &#39;capybara&#39;
  gem &#39;rspec-rails&#39;, &#39;~&amp;gt; 4.0.0&#39;

  # lets spring work with rspec - uncomment if using spring
  # gem &#39;spring-commands-rspec&#39;
end

group :test do
  # easier tests (inside rspec)
  gem &#39;shoulda-matchers&#39;

  # cucumber can test emails (rspec too?)
  # gem &#39;email_spec&#39;

  # code coverage
  gem &#39;simplecov&#39;
  gem &#39;simplecov-console&#39;
end
EOF

# update gems with
bundle install

# install rspec with:
bin/rails g rspec:install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;configure-rspec&#34;&gt;CONFIGURE RSPEC&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# create a spec features folder
mkdir spec/features
# create a place to put commonly used tests code
mkdir spec/support
mkdir spec/support/features

# at the top of `spec/rails_helper.rb below `require &#39;rspec/rails&#39;` add:
# to enable integration tests with rspec &amp;amp; capybara
require &#39;capybara/rspec&#39;
# include custom support files
Dir[Rails.root.join(&amp;quot;spec/support/**/*.rb&amp;quot;)].each { |file| require file }


# just after the ActiveRecord config and before RSpec.configure block add:
Capybara.register_driver :selenium_chrome do |app|
  Capybara::Selenium::Driver.new(app, browser: :chrome)
end
Capybara.javascript_driver = :selenium_chrome


# add FactoryBot config to Rspec in `spec/rails_helper.rb`
RSpec.configure do |config|
  # ...

  # support for Factory Bot
  config.include FactoryBot::Syntax::Methods

  # setup devise login helpers in Rspec
  config.include Devise::Test::IntegrationHelpers, type: :request
  config.include Warden::Test::Helpers
end

# support for shoulda matches
Shoulda::Matchers.configure do |config|
  config.integrate do |with|
    with.test_framework :rspec
    with.library :rails
  end
end

EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the rspec_helper.rb file now looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This file is copied to spec/ when you run &#39;rails generate rspec:install&#39;
require &#39;spec_helper&#39;

ENV[&#39;RAILS_ENV&#39;] ||= &#39;test&#39;
require File.expand_path(&#39;../config/environment&#39;, __dir__)
# Prevent database truncation if the environment is production
abort(&amp;quot;The Rails environment is running in production mode!&amp;quot;) if Rails.env.production?
require &#39;rspec/rails&#39;

# to enable integration tests with rspec
require &#39;capybara/rspec&#39;

# include custom support files
Dir[Rails.root.join(&amp;quot;spec/support/**/*.rb&amp;quot;)].each { |file| require file }

# Add additional requires below this line. Rails is not loaded until this point!

# Requires supporting ruby files with custom matchers and macros, etc, in
# spec/support/ and its subdirectories. Files matching `spec/**/*_spec.rb` are
# run as spec files by default. This means that files in spec/support that end
# in _spec.rb will both be required and run as specs, causing the specs to be
# run twice. It is recommended that you do not name files matching this glob to
# end with _spec.rb. You can configure this pattern with the --pattern
# option on the command line or in ~/.rspec, .rspec or `.rspec-local`.
#
# The following line is provided for convenience purposes. It has the downside
# of increasing the boot-up time by auto-requiring all files in the support
# directory. Alternatively, in the individual `*_spec.rb` files, manually
# require only the support files necessary.
#
# Dir[Rails.root.join(&#39;spec&#39;, &#39;support&#39;, &#39;**&#39;, &#39;*.rb&#39;)].sort.each { |f| require f }

# Checks for pending migrations and applies them before tests are run.
# If you are not using ActiveRecord, you can remove these lines.
begin
  ActiveRecord::Migration.maintain_test_schema!
rescue ActiveRecord::PendingMigrationError =&amp;gt; e
  puts e.to_s.strip
  exit 1
end

# configure capybara integration tests
Capybara.register_driver :selenium_chrome do |app|
  Capybara::Selenium::Driver.new(app, browser: :chrome)
end
Capybara.javascript_driver = :selenium_chrome

RSpec.configure do |config|
  # Remove this line if you&#39;re not using ActiveRecord or ActiveRecord fixtures
  config.fixture_path = &amp;quot;#{::Rails.root}/spec/fixtures&amp;quot;

  # If you&#39;re not using ActiveRecord, or you&#39;d prefer not to run each of your
  # examples within a transaction, remove the following line or assign false
  # instead of true.
  config.use_transactional_fixtures = true

  # You can uncomment this line to turn off ActiveRecord support entirely.
  # config.use_active_record = false

  # RSpec Rails can automatically mix in different behaviours to your tests
  # based on their file location, for example enabling you to call `get` and
  # `post` in specs under `spec/controllers`.
  #
  # You can disable this behaviour by removing the line below, and instead
  # explicitly tag your specs with their type, e.g.:
  #
  #     RSpec.describe UsersController, type: :controller do
  #       # ...
  #     end
  #
  # The different available types are documented in the features, such as in
  # https://relishapp.com/rspec/rspec-rails/docs
  config.infer_spec_type_from_file_location!

  # Filter lines from Rails gems in backtraces.
  config.filter_rails_from_backtrace!
  # arbitrary gems may also be filtered via:
  # config.filter_gems_from_backtrace(&amp;quot;gem name&amp;quot;)

  # support for Factory Bot
  config.include FactoryBot::Syntax::Methods

  # setup devise login helpers in Rspec (login helpers)
  config.include Devise::Test::IntegrationHelpers, type: :request
  # allows us for force session logouts (im feature tests)
  config.include Warden::Test::Helpers
end

Shoulda::Matchers.configure do |config|
  config.integrate do |with|
    with.test_framework :rspec
    with.library :rails
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you plan to user database_cleaner &amp;ndash; then also see this article to finishy yoru config:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@amliving/my-rails-rspec-set-up-6451269847f9&#34;&gt;https://medium.com/@amliving/my-rails-rspec-set-up-6451269847f9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;a basic login feature test might look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  let(:user)  { FactoryBot.create :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user logs in successfully&#39; do
    scenario &#39;and is redirected to user home page&#39; do
      user_log_in(user)
      expect(current_path).to eql(auth_user_root_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;configure-for-actiontext-and-activestorage&#34;&gt;Configure for ActionText and ActiveStorage&lt;/h2&gt;
&lt;p&gt;uncomment the following gem for Active Storage variant&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gem &#39;image_processing&#39;, &#39;~&amp;gt; 1.2&#39;
# of course
bundle install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now install the components:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bundle exec rails webpacker:install
bundle exec rails webpacker:install:stimulus
bundle exec rails active_storage:install
bundle exec rails action_text:install
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lets-create-a-landing-page---before-we-install-and-configure-devise&#34;&gt;Lets create a landing page - before we install and configure devise:&lt;/h3&gt;
&lt;p&gt;Since I don&amp;rsquo;t use helpers (generally) nor contoller or view spec - I use thie following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails g controller Landing index --no-helper --no-assets --no-controller-specs --no-view-specs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now check or add this the root page to: &lt;code&gt;config/routes.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  
  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  # get &#39;landing/index&#39;
  root to: &amp;quot;landing#index&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lets add a hidden paragraph as content to the top of the landing page so we can easily test for it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lets create the following feature test (to test the feature setup):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/features/landing_page_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Landing Page Works without a login&#39;, type: :feature do
  scenario &#39;Visit landing Page&#39; do
    visit root_path
    
    page_tag = find(&#39;p#landing_index&#39;, text: &#39;Landing Index&#39;, visible: false)
    expect(page_tag).to be_truthy
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;create a request test to be sure it works as we wish (we dont need a feature test when we arent navigating)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RSpec.describe &amp;quot;Landings&amp;quot;, type: :request do

  describe &amp;quot;GET /index&amp;quot; do
    it &amp;quot;&#39;/landing&#39; returns http success&amp;quot; do
      get &amp;quot;/landing&amp;quot;
      expect(response).to have_http_status(:success)
      expect(response.body).to include(&amp;quot;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;&amp;quot;)
    end
    it &amp;quot;&#39;landing_path&#39; returns http success&amp;quot; do
      get landing_path
      expect(response).to have_http_status(:success)
      expect(response.body).to include(&amp;quot;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;&amp;quot;)
    end
    it &amp;quot;&#39;/&#39; returns http success&amp;quot; do
      get &amp;quot;/&amp;quot;
      expect(response).to have_http_status(:success)
      expect(response.body).to include(&amp;quot;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;&amp;quot;)
    end
    it &amp;quot;&#39;root_path&#39; returns http success&amp;quot; do
      get root_path
      expect(response).to have_http_status(:success)
      expect(response.body).to include(&amp;quot;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;&amp;quot;)
    end
    # it &amp;quot;&#39;/landing/index&#39; returns http success&amp;quot; do
    #   get &amp;quot;/landing/index&amp;quot;
    #   expect(response).to have_http_status(:success)
    #   expect(response.body).to include(&amp;quot;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;&amp;quot;)
    # end
    # it &amp;quot;&#39;landing_index_path&#39; returns http success&amp;quot; do
    #   get landing_index_path
    #   expect(response).to have_http_status(:success)
    #   expect(response.body).to include(&amp;quot;&amp;lt;p hidden id=&#39;landing_index&#39;&amp;gt;Landing Index&amp;lt;/p&amp;gt;&amp;quot;)
    # end
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assumign all it green - lets commit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;rspec configured and working&amp;quot;
git push
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rails Devise User with Roles</title>
      <link>https://btihen.me/post_ruby_rails/robust_rails_03_devise_single_user_with_roles/</link>
      <pubDate>Fri, 10 Jul 2020 20:45:51 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/robust_rails_03_devise_single_user_with_roles/</guid>
      <description>&lt;h2 id=&#34;configure-devise-for-multiple-types-of-accounts&#34;&gt;Configure devise (for multiple types of accounts)&lt;/h2&gt;
&lt;p&gt;install the devise engine:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/rails generate devise:install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now follow the basic setup config &amp;ndash; add to &lt;code&gt;config/environments/development.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config.action_mailer.default_url_options = { host: &#39;localhost&#39;, port: 3000 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add notifications to the layout for devise in &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; just above &lt;code&gt;&amp;lt;%= yeild %&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p class=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;alert&amp;quot;&amp;gt;&amp;lt;%= alert %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now create one or more models for devise:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails g devise:views
rails generate devise user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update the routes to put the login in separate routes in &lt;code&gt;config/routes.rb&lt;/code&gt; - make the routes look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  devise_for :users,  path: &#39;users&#39;  # http://localhost:3000/users/sign_in
  devise_for :admins, path: &#39;admins&#39; # http://localhost:3000/admins/sign_in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;turn on scoped views (since login forms can be different) in &lt;code&gt;config/initializers/devise.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config.scoped_views = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create the scoped views: (instead of: rails g devise:views) do:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails g devise:views users/devise
rails g devise:views admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we should open these migrations and uncomment any added fields we use - I generally like to use most of the fields:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frozen_string_literal: true

class DeviseCreateAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    create_table :admins do |t|
      ## Database authenticatable
      t.string :email,              null: false, default: &amp;quot;&amp;quot;
      t.string :encrypted_password, null: false, default: &amp;quot;&amp;quot;

      ## Recoverable
      t.string   :reset_password_token
      t.datetime :reset_password_sent_at

      ## Rememberable
      t.datetime :remember_created_at

      ## Trackable
      t.integer  :sign_in_count, default: 0, null: false
      t.datetime :current_sign_in_at
      t.datetime :last_sign_in_at
      t.inet     :current_sign_in_ip
      t.inet     :last_sign_in_ip

      ## Confirmable
      t.string   :confirmation_token
      t.datetime :confirmed_at
      t.datetime :confirmation_sent_at
      t.string   :unconfirmed_email # Only if using reconfirmable

      ## Lockable
      t.integer  :failed_attempts, default: 0, null: false # Only if lock strategy is :failed_attempts
      t.string   :unlock_token # Only if unlock strategy is :email or :both
      t.datetime :locked_at

      t.timestamps null: false
    end

    add_index :admins, :email,                unique: true
    add_index :admins, :reset_password_token, unique: true
    add_index :admins, :confirmation_token,   unique: true
    add_index :admins, :unlock_token,         unique: true
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and adjust the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;admin&lt;/code&gt; models too and turn on the features we want or need. We will go into detail later, for now I will just add trackable to the models:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable, :trackable,
         :recoverable, :rememberable, :validatable
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and of course migrate too.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create custome controllers for each sessions - this also allows the users to have different fields and features:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails generate devise:controllers users/devise
rails generate devise:controllers admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;configure the routes to point to these new controllers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # http://localhost:3000/users/sign_in
  devise_for :users,  path: &#39;users&#39;,
                      controllers: {
                        sessions:      &#39;users/devise/sessions&#39;,
                        passwords:     &#39;users/devise/passwords&#39;,
                        registrations: &#39;users/devise/registrations&#39;
                      }
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now the routes should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bin/rails routes
                     Prefix Verb   URI Pattern                        Controller#Action
           new_user_session GET    /users/sign_in(.:format)           users/sessions#new
               user_session POST   /users/sign_in(.:format)           users/sessions#create
       destroy_user_session DELETE /users/sign_out(.:format)          users/sessions#destroy
          new_user_password GET    /users/password/new(.:format)      users/passwords#new
         edit_user_password GET    /users/password/edit(.:format)     users/passwords#edit
              user_password PATCH  /users/password(.:format)          users/passwords#update
                            PUT    /users/password(.:format)          users/passwords#update
                            POST   /users/password(.:format)          users/passwords#create
   cancel_user_registration GET    /users/cancel(.:format)            user/registrations#cancel
      new_user_registration GET    /users/sign_up(.:format)           user/registrations#new
     edit_user_registration GET    /users/edit(.:format)              user/registrations#edit
          user_registration PATCH  /users(.:format)                   user/registrations#update
                            PUT    /users(.:format)                   user/registrations#update
                            DELETE /users(.:format)                   user/registrations#destroy
                            POST   /users(.:format)                   user/registrations#create
          new_admin_session GET    /admins/sign_in(.:format)          admin/sessions#new
              admin_session POST   /admins/sign_in(.:format)          admin/sessions#create
      destroy_admin_session DELETE /admins/sign_out(.:format)         admin/sessions#destroy
         new_admin_password GET    /admins/password/new(.:format)     admin/passwords#new
        edit_admin_password GET    /admins/password/edit(.:format)    admin/passwords#edit
             admin_password PATCH  /admins/password(.:format)         admin/passwords#update
                            PUT    /admins/password(.:format)         admin/passwords#update
                            POST   /admins/password(.:format)         admin/passwords#create
  cancel_admin_registration GET    /admins/cancel(.:format)           admin/registrations#cancel
     new_admin_registration GET    /admins/sign_up(.:format)          admin/registrations#new
    edit_admin_registration GET    /admins/edit(.:format)             admin/registrations#edit
         admin_registration PATCH  /admins(.:format)                  admin/registrations#update
                            PUT    /admins(.:format)                  admin/registrations#update
                            DELETE /admins(.:format)                  admin/registrations#destroy
                            POST   /admins(.:format)                  admin/registrations#create
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lets make logged in home pages (for the user and admin)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails g controller users/home index --no-helper --no-assets --no-controller-specs --no-view-specs
rails g controller admins/home index --no-helper --no-assets --no-controller-specs --no-view-specs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now lets update our routes to ponit to these pages if the user is logged in add the following belos the deivse_for commands&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rails.application.routes.draw do
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
  # http://localhost:3000/umdzes/sign_in
  devise_for :umdzes, path: &#39;umdzes&#39;,
                      controllers: {
                        sessions:      &#39;umdzes/devise/sessions&#39;,
                        passwords:     &#39;umdzes/devise/passwords&#39;,
                        registrations: &#39;umdzes/devise/registrations&#39;
                      }
  # http://localhost:3000/patrons/sign_in
  devise_for :patrons,  path: &#39;patrons&#39;,
                      controllers: {
                        sessions:      &#39;patrons/devise/sessions&#39;,
                        passwords:     &#39;patrons/devise/passwords&#39;,
                        registrations: &#39;patrons/devise/registrations&#39;
                      }

  authenticated :patron do
    root &#39;patrons/home#index&#39;,     as: :auth_patron_root
  end
  authenticated :umdze do
    root &#39;umdzes/home#index&#39;,      as: :auth_umdze_root
  end
  authenticated :admin do
    root &#39;admins/home#index&#39;, as: :auth_admin_root
  end


  namespace :admins do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/admins&#39;, to: &#39;admins/home#index&#39;, as: :admins

  namespace :umdzes do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/umdzes&#39;, to: &#39;umdzes/home#index&#39;, as: :umdzes

  namespace :patrons do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/patrons&#39;, to: &#39;patrons/home#index&#39;, as: :patrons

  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  get &#39;landing/index&#39;
  root to: &amp;quot;landing#index&amp;quot;
end

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-make-applicationcontrollers-for-each-namespace--enforce-authentication&#34;&gt;now lets make ApplicationControllers for each namespace &amp;amp; enforce authentication&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;touch app/controllers/admins/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/admins/application_controller.rb
class Admins::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_admin!

  private

  def this_user
    current_admin
  end
end
EOF

touch app/controllers/umdzes/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/umdzes/application_controller.rb
class Umdzes::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_umdze!, unless: :allowed_access

  private

  def allowed_access
    current_admin
  end

  def this_user
    current_umdze || current_admin
  end
end
EOF

touch app/controllers/patrons/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/patrons/application_controller.rb
class Patrons::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_patron!, unless: :allowed_access

  private
  def allowed_access
    current_umdze || current_admin
  end

  def this_user
    current_patron || current_umdze || current_admin
  end
end
EOF

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;now-we-will-inhert-from-these-new-controllers-and-enforce-limits&#34;&gt;now we will inhert from these new controllers and enforce limits&lt;/h1&gt;
&lt;p&gt;now lets require these pages to have authenticated the correct user type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/controllers/admins/home_controller.rb
class Admins::HomeController &amp;lt; Admins::ApplicationController
  def index
  end
end

# app/controllers/umdzes/home_controller.rb
class Umdzes::HomeController &amp;lt; Umdzes::ApplicationController
  def index
  end
end

# app/controllers/patrons/home_controller.rb
class Patrons::HomeController &amp;lt; Patrons::ApplicationController
  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-prevent-student-and-admin-accounts-from-cross-visits-during-testing-or-whatever&#34;&gt;Now prevent student and admin accounts from cross visits (during testing, or whatever)&lt;/h2&gt;
&lt;p&gt;create this new file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch app/controllers/concerns/accessible.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/concerns/accessible.rb
module Accessible
  extend ActiveSupport::Concern
  included do
    before_action :check_user
  end

  protected
  def check_user
    if current_admin
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_admin_root_path) and return
    elsif current_umdze
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_umdze_root_path) and return
    elsif current_patron
      flash.clear
      # The authenticated user root path can be defined in your routes.rb in: devise_scope :user do...
      redirect_to(auth_partron_root_path) and return
    end
  end
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;use-this-accessible-concern&#34;&gt;use this accessible concern&lt;/h2&gt;
&lt;p&gt;Now add &lt;code&gt;include Accessible&lt;/code&gt; in the appropriate controllers:&lt;/p&gt;
&lt;p&gt;Note:
You must skip_before_action for the destroy action in each SessionsController to prevent the redirect to happen before the sign out occurs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# eg. ../controllers/admins/sessions_controller.rb
class Admins::SessionsController &amp;lt; Devise::SessionsController
 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/admins/registrations_controller.rb
You must also skip_before_action for the edit, update, destroy, and cancel actions in each RegistrationsController to allow current users to edit and cancel their own accounts. Otherwise they will be redirected before they can reach these pages.

class Admins::RegistrationsController &amp;lt; Devise::RegistrationsController
 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/umdzes/sessions_controller.rb
class Umdzes::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/umdzes/registrations_controller.rb
class Umdzes::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/patrons/sessions_controller.rb
class Patrons::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/patrons/registrations_controller.rb
class Patrons::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-give-the-patron-account-a-usernames&#34;&gt;now lets give the patron account a usernames&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails generate migration add_username_to_patrons username:string:uniq
rails generate migration add_umdzes_name_to_umdzes fullname:string
rails generate migration add_admins_name_to_admins fullname:string

# now update the new migration to look like:
class AddUsernamToPatrons &amp;lt; ActiveRecord::Migration[6.0]
  def change
    # username is key not email - in fact we don&#39;t want an email
    rename_column :patrons, :email, :username
  end
end

class AddFullnameToUmdzes &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :umdzes, :umdzes_name, :string, null: false
  end
end

class AddFullnameToAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :admins, :admins_name, :string, null: false
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;update-the-models&#34;&gt;update the models&lt;/h2&gt;
&lt;p&gt;now we need to go to the models and make the following updates:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/models/admin.rb
class Admin &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :admins_name, presence: true
end

# app/models/umdze.rb
class Umdze &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :umdzes_name, presence: true
end


# app/models/patrons.rb
class Patron &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable, # :recoverable
          :authentication_keys =&amp;gt; [:username]

  validates :username, uniqueness: true
  # make the email field optional
  # validates :email, uniqueness: true

  def email_required?
    false
  end

  def email_changed?
    false
  end

  # use this instead of email_changed? for Rails = 5.1.x
  def will_save_change_to_email?
    false
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we can safely migrate &lt;code&gt;bundle exec rails db:migrate&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;lets-test-our-logins&#34;&gt;lets test our logins&lt;/h2&gt;
&lt;p&gt;lets create some common feature test code:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&#34;&gt;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&lt;/a&gt;
&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/support/features/session_helpers.rb
module Features
  module SessionHelpers
    # def patron_sign_up(username:, password:)
    #   visit new_patron_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Username&#39;, with: username
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def patron_log_in(patron = nil)
      patron = FactoryBot.create :patron if patron.nil?
      visit new_patron_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Username&#39;, with: patron.username
      fill_in &#39;Password&#39;, with: patron.password
      click_on &#39;Log in&#39;
    end

    # def umdze_sign_up(email:, password:)
    #   visit new_umdze_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def umdze_log_in(umdze = nil)
      umdze = FactoryBot.create :umdze if umdze.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end

    # def admin_sign_up(email:, password:)
    #   visit new_admin_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def admin_log_in(admin = nil)
      admin = FactoryBot.create :admin if admin.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are not allowing registrations, so that code is commented out.  However, we see we must configure our factories for this code to work.&lt;/p&gt;
&lt;p&gt;Lets tell rspec how to access this code in feature tests:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/support/features.rb
RSpec.configure do |config|
  config.include Features::SessionHelpers, type: :feature
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-create-test-for-our-devise-model-factories&#34;&gt;Lets create test for our devise model factories:&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# spec/models/patron_spec.rb
require &#39;rails_helper&#39;

RSpec.describe User, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end

# spec/models/admin_spec.rb
require &#39;rails_helper&#39;

RSpec.describe Admin, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these fail - run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to configure the factories so all is working:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/factories/patrons.rb
FactoryBot.define do
  factory :user do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow&#39; }
    password_confirmation { &#39;LetM3-InNow&#39; }
    # enable this if using confirmable
    # confirmed_at { Date.today }
  end
end

# spec/factories/umdzes.rb
FactoryBot.define do
  factory :umdze do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    umdzes_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

# spec/factories/admins.rb
FactoryBot.define do
  factory :admin do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    admins_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these pass now - run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we are ready to test devise and our restricted access to the users home page:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.madetech.com/blog/feature-testing-with-rspec&#34;&gt;https://www.madetech.com/blog/feature-testing-with-rspec&lt;/a&gt;
&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;
&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&lt;/a&gt;
&lt;a href=&#34;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&#34;&gt;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&lt;/a&gt;
&lt;a href=&#34;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&#34;&gt;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/features/users/user_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  # note user is NOT created in DB!
  let(:user)  { FactoryBot.build :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user is not signed-up&#39; do
    scenario &#39;user signs-up on registration page&#39; do
      user_sign_up(email: user.email, password: user.password)
      expect(current_path).to eql(users_home_path)
    end
  end
end


# spec/features/users/user_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  let(:user)  { FactoryBot.create :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user logs in successfully&#39; do
    scenario &#39;and is redirected to user home page&#39; do
      user_log_in(user)
      expect(current_path).to eql(auth_user_root_path)
    end
  end
end


# spec/features/users_home_page_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  let(:user)    { FactoryBot.create :user }
  after :each do
    # force a logout (clear warden info) after each test
    Warden.test_reset!
  end
  describe &#39;user is not authenticated&#39; do
    scenario &#39;user is redirected to user login before access to user home&#39; do
      visit users_home_path
      expect(current_path).to eql(new_user_session_path)
    end
  end
  describe &#39;user is already authenticated&#39; do
    before    { user_log_in(user) }
    scenario &#39;user gets direct access to the user homepage&#39; do
      visit users_home_path
      expect(page).to have_current_path(users_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and test to be sure admin can log in too:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/features/admins/admin_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  after :each do
    Warden.test_reset!
  end
  scenario &#39;logs in successfully and is redirected to user home page&#39; do
    admin_log_in
    expect(current_path).to eql(auth_admin_root_path)
  end
end


# spec/features/admins/admin_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admin Signup&#39;, type: :feature do
  # IMPORTANT is NOT created in DB!
  let(:admin)  { FactoryBot.build :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;admin is not signed-up&#39; do
    scenario &#39;admin registers&#39; do
      admin_sign_up(email: admin.email, password: admin.password)
      expect(page).to have_current_path(admins_home_path)
    end
  end
end


# spec/features/admins/admins_home_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admins Home&#39;, type: :feature do
  let(:admin)  { FactoryBot.create :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;un-authenticated&#39; do
    scenario &#39;attempts to access admins home page is redirected to user login&#39; do
      visit admins_home_path
      expect(current_path).to eql(new_admin_session_path)
    end
  end
  describe &#39;already authenticated&#39; do
    before    { admin_log_in(admin) }
    scenario &#39;gets access to the user homepage&#39; do
      visit admins_home_path
      expect(current_path).to eql(admins_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;before we wrap up - we need to fix our request specs - now that we added login restrictions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/requests/users/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Patron::Homes&amp;quot;, type: :request do

  let(:patron)   { FactoryBot.create :patron }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;patron_home_path&#39; page is NOT accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in patron
      end
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;patrons_home_path&#39; page is accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/umdze/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Umdze::Homes&amp;quot;, type: :request do
  let(:umdze)   { FactoryBot.create :umdze }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is NOT accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in umdze
      end
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/admins/dashboard_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Admins::Dashboards&amp;quot;, type: :request do

  let(:admin)   { FactoryBot.create :admin }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      it &amp;quot;home as &#39;/admins&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is NOT accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in admin
      end
      after do
        sign_out admin
      end
      it &amp;quot;home as &#39;/admins&#39; page is accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run the tests and be sure all is green - if so, now is a good time to make a commit!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;rspec and devise configured and tests green&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
