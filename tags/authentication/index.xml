<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Authentication | btihen</title>
    <link>https://btihen.me/tags/authentication/</link>
      <atom:link href="https://btihen.me/tags/authentication/index.xml" rel="self" type="application/rss+xml" />
    <description>Authentication</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© 2021</copyright><lastBuildDate>Sun, 25 Apr 2021 01:01:53 +0200</lastBuildDate>
    <image>
      <url>https://btihen.me/img/btihen_landing_page.png</url>
      <title>Authentication</title>
      <link>https://btihen.me/tags/authentication/</link>
    </image>
    
    <item>
      <title>Phoenix 1.5 authentication with POW</title>
      <link>https://btihen.me/post_elixir_phoenix/phoenix_1_5_authentication_pow/</link>
      <pubDate>Sun, 25 Apr 2021 01:01:53 +0200</pubDate>
      <guid>https://btihen.me/post_elixir_phoenix/phoenix_1_5_authentication_pow/</guid>
      <description>&lt;p&gt;Pow has the advantage that it updates security patches &amp;ndash; since its a well maintained library.&lt;/p&gt;
&lt;p&gt;This repo can be found at: &lt;a href=&#34;https://github.com/btihen/phoenix_1_5_pow_auth_config&#34;&gt;https://github.com/btihen/phoenix_1_5_pow_auth_config&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Get the latest version from: &lt;a href=&#34;https://hex.pm/packages/pow&#34;&gt;https://hex.pm/packages/pow&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{:pow, &amp;quot;~&amp;gt; 1.0&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install the dependency:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix deps.get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install POW:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix pow.install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets verify all is good with the install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix deps.compile
mix help | grep pow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now hopefully you see some new &lt;code&gt;pow&lt;/code&gt; commands&lt;/p&gt;
&lt;h2 id=&#34;configure-pow&#34;&gt;Configure Pow&lt;/h2&gt;
&lt;p&gt;There are three files you&amp;rsquo;ll need to configure first before you can use Pow.&lt;/p&gt;
&lt;p&gt;First, append this to &lt;code&gt;config/config.exs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :fare, :pow,
  user: Fare.Users.User,
  repo: Fare.Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, add &lt;code&gt;Pow.Plug.Session&lt;/code&gt; plug to &lt;code&gt;lib/fare_web/endpoint.ex&lt;/code&gt; after &lt;code&gt;plug Plug.Session&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defmodule FareWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :fare   # add this line HERE!

  # ...

  plug Plug.Session, @session_options
  plug Pow.Plug.Session, otp_app: :fare  # add this line HERE!
  plug FareWeb.Router
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Last, update &lt;code&gt;lib/fare_web/router.ex&lt;/code&gt; with the Pow routes - this first time we need to do a little extra config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  pipeline :api do
    plug :accepts, [&amp;quot;json&amp;quot;]
  end
  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through [:browser, :protected]

    # Add your protected routes here
  end

  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through :browser

    live &amp;quot;/&amp;quot;, PageLive, :index
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Should now look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  pipeline :api do
    plug :accepts, [&amp;quot;json&amp;quot;]
  end

  pipeline :protected do
    plug Pow.Plug.RequiredAuthentication,
          error_handler: Pow.Phoenix.PlugErrorHandler
  end

  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
  end

  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through [:browser, :protected]

    # Add your protected routes here
    resources &amp;quot;/tasks&amp;quot;, TaskController
  end

  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through :browser

    live &amp;quot;/&amp;quot;, PageLive, :index
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets check the routes - that all is well configured:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix phx.routes | grep pow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hopefully you see some new pow routes.&lt;/p&gt;
&lt;p&gt;Now we can migrate to create our users table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we start phoenix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix phx.server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and open phoenix: &lt;code&gt;localhost:4000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;pow-user-links&#34;&gt;POW user Links&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Notice there is no menu option to login - lets build a simple signup/signin/logout link.&lt;/p&gt;
&lt;p&gt;In root.html.eex find &lt;code&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;https://hexdocs.pm/phoenix/overview.html&amp;quot;&amp;gt;Get Started&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/code&gt; and we will replace it with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            &amp;lt;%= if Pow.Plug.current_user(@conn) do %&amp;gt;
              &amp;lt;li&amp;gt;
                &amp;lt;%= link &amp;quot;#{@current_user.email}&amp;quot;, to: Routes.pow_registration_path(@conn, :edit) %&amp;gt;
              &amp;lt;/li&amp;gt;
              &amp;lt;li&amp;gt;
                &amp;lt;%= link &amp;quot;Sign-out&amp;quot;, to: Routes.pow_session_path(@conn, :delete), method: :delete %&amp;gt;
              &amp;lt;/li&amp;gt;
            &amp;lt;% else %&amp;gt;
              &amp;lt;li&amp;gt;&amp;lt;%= link &amp;quot;Sign-in&amp;quot;, to: Routes.pow_session_path(@conn, :new) %&amp;gt;&amp;lt;/li&amp;gt;
              &amp;lt;li&amp;gt;&amp;lt;%= link &amp;quot;Register&amp;quot;, to: Routes.pow_registration_path(@conn, :new) %&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now reload and try it out:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;you should be able to register&lt;/li&gt;
&lt;li&gt;sign-out&lt;/li&gt;
&lt;li&gt;sign in&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;customizable-login-pages&#34;&gt;Customizable Login pages&lt;/h2&gt;
&lt;p&gt;Generate the pages to customize with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix pow.phoenix.gen.templates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now be sure to change the config in &lt;code&gt;config/confix.ex&lt;/code&gt; from:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: Fare.Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without updating the config the newly generated pages won&amp;rsquo;t be used!&lt;/p&gt;
&lt;p&gt;The new templates to modify are found in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib/fare_web/templates/pow/registration&lt;/code&gt; &amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/fare_web/templates/pow/session&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now make a small change to the pages to ensure all works.&lt;/p&gt;
&lt;h2 id=&#34;create-a-restricted-user-page&#34;&gt;Create a restricted user page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Create a normal html page first:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix phx.gen.html Tasks Task tasks description:string completed:boolean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BE SURE TO PUT the new route in the &lt;code&gt;protected&lt;/code&gt; area of the routes file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# lib/fare_web/router.ex
  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through [:browser, :protected]

    # Add your protected routes here
    resources &amp;quot;/tasks&amp;quot;, TaskController
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now of course run the migration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now &lt;code&gt;/tasks&lt;/code&gt; should only be availble to signed in users.  Be sure you are logged out and cannot get to the &lt;code&gt;/tasks&lt;/code&gt; route (and infact are redirected to sign-in). And once logged in the page works as expected.&lt;/p&gt;
&lt;h2 id=&#34;extensions&#34;&gt;Extensions&lt;/h2&gt;
&lt;h3 id=&#34;persistent-login-sessions-remember-me&#34;&gt;Persistent Login Sessions (Remember me)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Currently every time the user closes the browser they are logged out - the login cookie doesn&amp;rsquo;t persist - most users would like the option to change this - with a &lt;code&gt;remember me&lt;/code&gt; option.&lt;/p&gt;
&lt;p&gt;in &lt;code&gt;config/config.exs&lt;/code&gt; change the &lt;code&gt;:pow&lt;/code&gt; config to look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  # add the following two lines
  extensions: [PowPersistentSession],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in &lt;code&gt;/lib/my_app_web/endpoint.ex&lt;/code&gt; we need to add the persistent cookie setting immediately after the &lt;code&gt;Pow.Plug.Session&lt;/code&gt; plug and before the routing &lt;code&gt;MyAppWeb.Router&lt;/code&gt; plug &amp;ndash; now the end of the endpoint file should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # enable Pow session based authentication
  plug Pow.Plug.Session, otp_app: :warehouse
  # enable Pow persistent sessions
  plug PowPersistentSession.Plug.Cookie
  # routing plug
  plug MyAppWeb.Router
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;just above the login button on the &lt;code&gt;sign-in&lt;/code&gt; page add the following check-box:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# lib/fare_web/templates/pow/session/new.html.eex
  &amp;lt;%= label f, :persistent_session, &amp;quot;Remember me&amp;quot; %&amp;gt;
  &amp;lt;%= checkbox f, :persistent_session %&amp;gt;

  &amp;lt;div&amp;gt;
    &amp;lt;%= submit &amp;quot;Sign in&amp;quot; %&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;restart Phoenix with: &lt;code&gt;mix phx.server&lt;/code&gt; and now you should be able to close your browser and re-open the link and stay logged in if the &lt;code&gt;remember-me&lt;/code&gt; is clicked.&lt;/p&gt;
&lt;h2 id=&#34;after-logout---go-to-landing-page-after-hook-routing&#34;&gt;After Logout - go to Landing Page (After Hook Routing)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One little annoying thing is that when we logout we go to the sign-in page instead of the landing page.  We can fix that by adding a call_back_route - you can find all the callback routes at: &lt;a href=&#34;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&#34;&gt;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&lt;/a&gt; - we will use: the &lt;code&gt;after_sign_out_path&lt;/code&gt; callback.&lt;/p&gt;
&lt;p&gt;To do this we will make a new &lt;code&gt;pow.routes&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch lib/warehouse_web/pow/routes.ex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF&amp;gt; lib/my_app_web/pow/routes.ex
defmodule MyAppWeb.Pow.Routes do
  use Pow.Phoenix.Routes
  alias MyAppWeb.Router.Helpers, as: Routes

  def after_sign_out_path(conn), do: Routes.page_path(conn, :index)
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now finally update &lt;code&gt;config/confix.exs&lt;/code&gt; by adding &lt;code&gt;routes_backend: MyAppWeb.Pow.Routes&lt;/code&gt; to the &lt;code&gt;:pow&lt;/code&gt; config so now it would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  extensions: [PowPersistentSession],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks,
  routes_backend: MyAppWeb.Pow.Routes    # add this line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming all works we will snapshot now!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;on logout go to landing page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;password-reset-and-email-confirmation&#34;&gt;Password Reset and Email Confirmation&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/pow-auth/pow_assent&#34;&gt;https://github.com/pow-auth/pow_assent&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The following are the possible extensions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PowResetPassword&lt;/li&gt;
&lt;li&gt;PowEmailConfirmation&lt;/li&gt;
&lt;li&gt;PowPersistentSession&lt;/li&gt;
&lt;li&gt;PowInvitation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s start with password reset and email confirmation.&lt;/p&gt;
&lt;p&gt;First we need to do a migration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix pow.extension.ecto.gen.migrations --extension PowResetPassword --extension PowEmailConfirmation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now update the phoenix config &lt;code&gt;config/config.ex&lt;/code&gt; again from:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now update the &lt;code&gt;LIB_PATH/users/user.ex&lt;/code&gt; file from:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defmodule Fare.Users.User do
  use Ecto.Schema
  use Pow.Ecto.Schema

  schema &amp;quot;users&amp;quot; do
    pow_user_fields()

    timestamps()
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defmodule MyApp.Users.User do
  use Ecto.Schema
  use Pow.Ecto.Schema
  use Pow.Extension.Ecto.Schema,
      extensions: [PowResetPassword, PowEmailConfirmation]

  schema &amp;quot;users&amp;quot; do
    pow_user_fields()

    timestamps()
  end

  def changeset(user_or_changeset, attrs) do
    user_or_changeset
    |&amp;gt; pow_changeset(attrs)
    |&amp;gt; pow_extension_changeset(attrs)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course the routes &lt;code&gt;WEB_PATH/router.ex&lt;/code&gt; too - at the top of the file add:
so it looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defmodule MyAppWeb.Router do
  use MyAppWeb, :router
  use Pow.Phoenix.Router
  use Pow.Extension.Phoenix.Router,
      extensions: [PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in the pow routes config change from:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
    pow_extension_routes()
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now finally, we need can update any views needed by POW&amp;rsquo;s new extensions with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix pow.extension.phoenix.gen.templates --extension PowResetPassword --extension PowEmailConfirmation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can update the sign-in page with a reset password button.  We will add the following, to the end of &lt;code&gt;lib/fare_web/templates/pow/session/new.html.eex&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|
&amp;lt;span&amp;gt;
&amp;lt;%= link &amp;quot;Reset Password&amp;quot;, to: Routes.pow_reset_password_reset_password_path(@conn, :new) %&amp;gt;
&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets be sure we can link to reset password view.&lt;/p&gt;
&lt;p&gt;First we will do our migration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now to to sign-in and see if the reset password link works.
Cool it does, but it we try to use it - it complains it needs email back-end setup.&lt;/p&gt;
&lt;h2 id=&#34;email-backend&#34;&gt;Email backend&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First we will create a mailer function in: &lt;code&gt;lib/my_app/pow_mailer.ex&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defmodule FareWeb.Pow.Mailer do
  use Pow.Phoenix.Mailer
  # use Bamboo.Mailer, otp_app: :fare
  require Logger

  # import Bamboo.Email

  @impl true
  def cast(%{user: user, subject: subject, text: text, html: html}) do
    # for use when Bamboo is configured
    # new_email(
    #   to: user.email,
    #   from: &amp;quot;reading-list@example.com&amp;quot;,
    #   subject: subject,
    #   html_body: html,
    #   text_body: text
    # )

    # send to logger - disable when
    %{to: user.email, subject: subject, text: text, html: html}
  end

  @impl true
  def process(email) do
    # actually deliver emails - enable when `bamboo` configured
    # deliver_now(email)

    # check email functionality and contents
    Logger.debug(&amp;quot;E-mail sent: #{inspect email}&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now that we have an email template we need to tell pow about the mailer with the config: &lt;code&gt;mailer_backend: MyAppWeb.Pow.Mailer&lt;/code&gt; in &lt;code&gt;config/confix.exs&lt;/code&gt; so change from:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config for pow - user authentication
config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# config for pow - user authentication
config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  mailer_backend: MyAppWeb.Pow.Mailer,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now generate any mail templates needed with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix pow.extension.phoenix.mailer.gen.templates --extension PowResetPassword --extension PowEmailConfirmation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Phoenix also needs to know about the mailer templates we will generate so add to &lt;code&gt;lib/my_app_web.ex&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  def mailer_view do
    quote do
      use Phoenix.View, root: &amp;quot;lib/my_app_web/templates&amp;quot;,
                        namespace: MyAppWeb

      use Phoenix.HTML
    end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the final config change in &lt;code&gt;config/config.ex&lt;/code&gt; from:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config for pow - user authentication
config :fare, :pow,
  user: Fare.Users.User,
  repo: Fare.Repo,
  web_module: FareWeb,
  mailer_backend: MyAppWeb.Pow.Mailer,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config for pow - user authentication
config :fare, :pow,
  user: Fare.Users.User,
  repo: Fare.Repo,
  web_module: FareWeb,
  web_mailer_module: MyAppWeb,
  mailer_backend: MyAppWeb.Pow.Mailer,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we resart phoenix and test out reset link - we should see in the logs &amp;lsquo;a pretend sent email&amp;rsquo; - something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[debug] E-mail sent: %{html: &amp;quot;&amp;lt;h3&amp;gt;Hi,&amp;lt;/h3&amp;gt;\n&amp;lt;p&amp;gt;Please use the following link to reset your password:&amp;lt;/p&amp;gt;\n&amp;lt;p&amp;gt;&amp;lt;a href=\&amp;quot;http://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw\&amp;quot;&amp;gt;http://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;\n&amp;lt;p&amp;gt;You can disregard this email if you didn&amp;amp;#39;t request a password reset.&amp;lt;/p&amp;gt;&amp;quot;, subject: &amp;quot;Reset password link&amp;quot;, text: &amp;quot;Hi,\n\nPlease use the following link to reset your password:\n\nhttp://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw\n\nYou can disregard this email if you didn&#39;t request a password reset.\n&amp;quot;, to: &amp;quot;btihen@gmail.com&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;copy the link out of the email in the log:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;into the browser - type a new password and try to login.&lt;/p&gt;
&lt;p&gt;Assuming all works we will snapshot now!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;pow configured to send emails - no sender yet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;after-logout---go-to-landing-page-after-hook-routing-1&#34;&gt;After Logout - go to Landing Page (After Hook Routing)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One little annoying thing is that when we logout we go to the sign-in page instead of the landing page.  We can fix that by adding a call_back_route - you can find all the callback routes at: &lt;a href=&#34;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&#34;&gt;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&lt;/a&gt; - we will use: the &lt;code&gt;after_sign_out_path&lt;/code&gt; callback.&lt;/p&gt;
&lt;p&gt;To do this we will make a new &lt;code&gt;pow.routes&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch lib/warehouse_web/pow/routes.ex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF&amp;gt; lib/my_app_web/pow/routes.ex
defmodule MyAppWeb.Pow.Routes do
  use Pow.Phoenix.Routes
  alias MyAppWeb.Router.Helpers, as: Routes

  def after_sign_out_path(conn), do: Routes.page_path(conn, :index)
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now finally update &lt;code&gt;config/confix.exs&lt;/code&gt; by adding &lt;code&gt;routes_backend: MyAppWeb.Pow.Routes&lt;/code&gt; to the &lt;code&gt;:pow&lt;/code&gt; config so now it would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  web_mailer_module: MyAppWeb,
  mailer_backend: MyAppWeb.Pow.Mailer,
  routes_backend: MyAppWeb.Pow.Routes,
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming all works we will snapshot now!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;on logout go to landing page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;configure-email-bamboo-with-pow&#34;&gt;Configure Email BAMBOO with POW&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Use Bamboo to do the mailing find the new versions at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hex.pm/packages/bamboo&#34;&gt;https://hex.pm/packages/bamboo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hex.pm/packages/bamboo_smtp&#34;&gt;https://hex.pm/packages/bamboo_smtp&lt;/a&gt;
Add to &lt;code&gt;mix.exs&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    {:bamboo, &amp;quot;~&amp;gt; 2.1&amp;quot;},
    {:bamboo_smtp, &amp;quot;~&amp;gt; 4.0&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also add bamboo to the &lt;code&gt;applications&lt;/code&gt; in mix - now it should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  def application do
    [
      mod: {Fare.Application, []},
      applications: [:bamboo, :bamboo_smtp],  # this was added
      extra_applications: [:logger, :runtime_tools]
    ]
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now install and setup up: &lt;a href=&#34;https://github.com/mailhog/&#34;&gt;https://github.com/mailhog/&lt;/a&gt; (on a MacOS) simply install with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and run mailhog with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or if you want mailhog running all the time in the background you can type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  brew services start mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or you can use: or &lt;a href=&#34;https://mailcatcher.me/&#34;&gt;https://mailcatcher.me/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;These serivices  - listen on &lt;code&gt;localhost:1025&lt;/code&gt; and you can view the email at: http://localhost:8025&lt;/p&gt;
&lt;p&gt;now configure the mail service (in &lt;code&gt;config/dev.exs&lt;/code&gt;) to use Mailhog or Mailcather with Phoenix by adding:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config/dev.exs
config :my_app, MyAppWeb.Pow.Mailer,
  adapter: Bamboo.SMTPAdapter,
  server: &amp;quot;localhost&amp;quot;,
  port: 1025
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in production it might look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config/config.exs
config :my_app, MyApp.Mailer,
  adapter: Bamboo.SMTPAdapter,
  server: &amp;quot;smtp.domain&amp;quot;,
  hostname: &amp;quot;your.domain&amp;quot;,
  port: 1025,
  username: &amp;quot;your.name@your.domain&amp;quot;, # or {:system, &amp;quot;SMTP_USERNAME&amp;quot;}
  password: &amp;quot;pa55word&amp;quot;, # or {:system, &amp;quot;SMTP_PASSWORD&amp;quot;}
  tls: :if_available, # can be `:always` or `:never`
  allowed_tls_versions: [:&amp;quot;tlsv1&amp;quot;, :&amp;quot;tlsv1.1&amp;quot;, :&amp;quot;tlsv1.2&amp;quot;], # or {:system, &amp;quot;ALLOWED_TLS_VERSIONS&amp;quot;} w/ comma seprated values (e.g. &amp;quot;tlsv1.1,tlsv1.2&amp;quot;)
  ssl: false, # can be `true`
  retries: 1,
  no_mx_lookups: false, # can be `true`
  auth: :if_available # can be `:always`. If your smtp relay requires authentication set it to `:always`.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Update the pow mail file &lt;code&gt;lib/read_it_later_web/pow/mailer.ex&lt;/code&gt; to use Bamboo - the code will look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defmodule MyAppWeb.Pow.Mailer do
  use Pow.Phoenix.Mailer
  use Bamboo.Mailer, otp_app: :my_app

  import Bamboo.Email

  @impl true
  def cast(%{user: user, subject: subject, text: text, html: html}) do
    new_email(
      to: user.email,
      from: &amp;quot;reading-list@example.com&amp;quot;,
      subject: subject,
      html_body: html,
      text_body: text
    )
  end

  @impl true
  def process(email) do
    deliver_now(email)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;adding-flash-messages-to-pow&#34;&gt;Adding flash messages to POW&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;configure-to-allow-3rd-parties---google-apple-github-etc&#34;&gt;Configure to allow 3rd Parties - Google, Apple, Github, etc.&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/pow-auth/pow_assent&#34;&gt;https://github.com/pow-auth/pow_assent&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First add to the mix file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    # third party auth
    {:pow_assent, &amp;quot;~&amp;gt; 0.4.10&amp;quot;},
    # recommended for SSL validation with :httpc adapter
    {:certifi, &amp;quot;~&amp;gt; 2.4&amp;quot;},
    {:ssl_verify_fun, &amp;quot;~&amp;gt; 1.1&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and of course: &lt;code&gt;mix deps.get&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and install with: &lt;code&gt;mix pow_assent.install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and now configure &lt;code&gt;lib/fare/users/user.ex&lt;/code&gt; after &lt;code&gt;use Pow.Ecto.Schema&lt;/code&gt; add &lt;code&gt;use PowAssent.Ecto.Schema&lt;/code&gt; so now the top of this file should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# lib/fare/users/user.ex
defmodule Fare.Users.User do
  use Ecto.Schema
  use Pow.Ecto.Schema
  use PowAssent.Ecto.Schema  # added in this step
  use Pow.Extension.Ecto.Schema,
      extensions: [PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At the top of the &lt;code&gt;lib/fare_web/router.ex&lt;/code&gt; file after &lt;code&gt;use PowAssent.Phoenix.Router&lt;/code&gt; add &lt;code&gt;use PowAssent.Phoenix.Router&lt;/code&gt; - now the top of this file should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# lib/fare_web/router.ex
defmodule MyAppWeb.Router do
  use MyAppWeb, :router
  use Pow.Phoenix.Router
  use PowAssent.Phoenix.Router
  use Pow.Extension.Phoenix.Router,
      extensions: [PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now after the last pipelines add a new &lt;code&gt;pipeline&lt;/code&gt; and its &lt;code&gt;scope&lt;/code&gt; - its a copy of the &lt;code&gt;:browser&lt;/code&gt; pipeline - without &lt;code&gt;:protect_from_forgery&lt;/code&gt; since that conflicts with &lt;strong&gt;OAuth&lt;/strong&gt; &amp;amp; after &lt;code&gt;pow_routes()&lt;/code&gt; add &lt;code&gt;pow_assent_routes()&lt;/code&gt; so now this section of the routes looks like (when Phoenix is configured for LiveView):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  pipeline :skip_csrf_protection do
    plug :accepts, [&amp;quot;html&amp;quot;]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, {FareWeb.LayoutView, :root}
    # plug :protect_from_forgery     # conflicts with oauth
    plug :put_secure_browser_headers
  end

  scope &amp;quot;/&amp;quot; do
    pipe_through :skip_csrf_protection

    # this adds new pow routes
    pow_assent_authorization_post_callback_routes()
  end

  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
    pow_assent_routes()    # newly added
    pow_extension_routes()
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember to run the new migrations with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generate the PowAssent template too (the page when using this where the user add username and OAuth password from remote site):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix pow_assent.phoenix.gen.templates
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;setup-remote-oautho-providers-github---for-now&#34;&gt;Setup remote OAutho providers (Github - for now)&lt;/h3&gt;
&lt;p&gt;Go to:
&lt;a href=&#34;https://github.com/settings/applications/new&#34;&gt;https://github.com/settings/applications/new&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enter an &lt;strong&gt;Application name&lt;/strong&gt; and enter the &lt;strong&gt;Homepage url&lt;/strong&gt; as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:4000/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the &lt;strong&gt;Authorization callback&lt;/strong&gt; (for our dev environment) as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:4000/auth/github/callback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Configure Github Credential Secrets&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hexdocs.pm/elixir/Application.html&#34;&gt;https://hexdocs.pm/elixir/Application.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devato.com/post/handling-environment-variables-in-phoenix&#34;&gt;https://devato.com/post/handling-environment-variables-in-phoenix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/44510403/phoenix-import-module-into-config&#34;&gt;https://stackoverflow.com/questions/44510403/phoenix-import-module-into-config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/30995743/how-to-get-a-variable-value-from-environment-files-in-phoenix&#34;&gt;https://stackoverflow.com/questions/30995743/how-to-get-a-variable-value-from-environment-files-in-phoenix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First update &lt;code&gt;.gitignore&lt;/code&gt; with the line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**/*.secret.exs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then add in our case the &lt;code&gt;dev.secrets.exs&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch config/dev.secret.exs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you get your &lt;strong&gt;Client ID&lt;/strong&gt; and &lt;strong&gt;Client secrets&lt;/strong&gt; you can configure  &lt;code&gt;config/dev.secret.exs&lt;/code&gt; with the following config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Config

config :my_app, :pow_assent,
  providers: [
    github: [
      client_id: &amp;quot;REPLACE_WITH_CLIENT_ID&amp;quot;,
      client_secret: &amp;quot;REPLACE_WITH_CLIENT_SECRET&amp;quot;,
      strategy: Assent.Strategy.Github
    ]
  ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now at the END of &lt;code&gt;config/dev.exs&lt;/code&gt; add the line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import_config &amp;quot;dev.secret.exs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now at the end of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib/my_app_web/templates/pow/registration/edit.html.eex&lt;/code&gt; (edit profile),&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/my_app_web/templates/pow/registration/new.html.eex&lt;/code&gt; (register),&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/fare_web/templates/pow/session/new.html.eex&lt;/code&gt; (sign-in)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add the following comprehension to list all the configured OAuth log-in links:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=
  for link &amp;lt;- PowAssent.Phoenix.ViewHelpers.provider_links(@conn),
      do: content_tag(:span, link)
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pow readme: &lt;a href=&#34;https://hexdocs.pm/pow/README.html&#34;&gt;https://hexdocs.pm/pow/README.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;video tutorial: &lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;add pubsub &lt;a href=&#34;https://curiosum.dev/blog/elixir-phoenix-liveview-messenger-part-3&#34;&gt;https://curiosum.dev/blog/elixir-phoenix-liveview-messenger-part-3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;add email to pow: &lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rails Devise User Model with Roles</title>
      <link>https://btihen.me/post_ruby_rails/rails_devise_users_namespaced/</link>
      <pubDate>Fri, 10 Jul 2020 20:45:51 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/rails_devise_users_namespaced/</guid>
      <description>&lt;h2 id=&#34;configure-devise-for-multiple-types-of-accounts&#34;&gt;Configure devise (for multiple types of accounts)&lt;/h2&gt;
&lt;p&gt;install the devise engine:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/rails generate devise:install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now follow the basic setup config &amp;ndash; add to &lt;code&gt;config/environments/development.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config.action_mailer.default_url_options = { host: &#39;localhost&#39;, port: 3000 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add notifications to the layout for devise in &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; just above &lt;code&gt;&amp;lt;%= yeild %&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p class=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;alert&amp;quot;&amp;gt;&amp;lt;%= alert %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now create one or more models for devise:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails g devise:views
rails generate devise user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update the routes to put the login in separate routes in &lt;code&gt;config/routes.rb&lt;/code&gt; - make the routes look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  devise_for :users,  path: &#39;users&#39;  # http://localhost:3000/users/sign_in
  devise_for :admins, path: &#39;admins&#39; # http://localhost:3000/admins/sign_in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;turn on scoped views (since login forms can be different) in &lt;code&gt;config/initializers/devise.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config.scoped_views = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create the scoped views: (instead of: rails g devise:views) do:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails g devise:views users/devise
rails g devise:views admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we should open these migrations and uncomment any added fields we use - I generally like to use most of the fields:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frozen_string_literal: true

class DeviseCreateAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    create_table :admins do |t|
      ## Database authenticatable
      t.string :email,              null: false, default: &amp;quot;&amp;quot;
      t.string :encrypted_password, null: false, default: &amp;quot;&amp;quot;

      ## Recoverable
      t.string   :reset_password_token
      t.datetime :reset_password_sent_at

      ## Rememberable
      t.datetime :remember_created_at

      ## Trackable
      t.integer  :sign_in_count, default: 0, null: false
      t.datetime :current_sign_in_at
      t.datetime :last_sign_in_at
      t.inet     :current_sign_in_ip
      t.inet     :last_sign_in_ip

      ## Confirmable
      t.string   :confirmation_token
      t.datetime :confirmed_at
      t.datetime :confirmation_sent_at
      t.string   :unconfirmed_email # Only if using reconfirmable

      ## Lockable
      t.integer  :failed_attempts, default: 0, null: false # Only if lock strategy is :failed_attempts
      t.string   :unlock_token # Only if unlock strategy is :email or :both
      t.datetime :locked_at

      t.timestamps null: false
    end

    add_index :admins, :email,                unique: true
    add_index :admins, :reset_password_token, unique: true
    add_index :admins, :confirmation_token,   unique: true
    add_index :admins, :unlock_token,         unique: true
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and adjust the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;admin&lt;/code&gt; models too and turn on the features we want or need. We will go into detail later, for now I will just add trackable to the models:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable, :trackable,
         :recoverable, :rememberable, :validatable
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and of course migrate too.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create custome controllers for each sessions - this also allows the users to have different fields and features:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails generate devise:controllers users/devise
rails generate devise:controllers admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;configure the routes to point to these new controllers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # http://localhost:3000/users/sign_in
  devise_for :users,  path: &#39;users&#39;,
                      controllers: {
                        sessions:      &#39;users/devise/sessions&#39;,
                        passwords:     &#39;users/devise/passwords&#39;,
                        registrations: &#39;users/devise/registrations&#39;
                      }
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now the routes should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bin/rails routes
                     Prefix Verb   URI Pattern                        Controller#Action
           new_user_session GET    /users/sign_in(.:format)           users/sessions#new
               user_session POST   /users/sign_in(.:format)           users/sessions#create
       destroy_user_session DELETE /users/sign_out(.:format)          users/sessions#destroy
          new_user_password GET    /users/password/new(.:format)      users/passwords#new
         edit_user_password GET    /users/password/edit(.:format)     users/passwords#edit
              user_password PATCH  /users/password(.:format)          users/passwords#update
                            PUT    /users/password(.:format)          users/passwords#update
                            POST   /users/password(.:format)          users/passwords#create
   cancel_user_registration GET    /users/cancel(.:format)            user/registrations#cancel
      new_user_registration GET    /users/sign_up(.:format)           user/registrations#new
     edit_user_registration GET    /users/edit(.:format)              user/registrations#edit
          user_registration PATCH  /users(.:format)                   user/registrations#update
                            PUT    /users(.:format)                   user/registrations#update
                            DELETE /users(.:format)                   user/registrations#destroy
                            POST   /users(.:format)                   user/registrations#create
          new_admin_session GET    /admins/sign_in(.:format)          admin/sessions#new
              admin_session POST   /admins/sign_in(.:format)          admin/sessions#create
      destroy_admin_session DELETE /admins/sign_out(.:format)         admin/sessions#destroy
         new_admin_password GET    /admins/password/new(.:format)     admin/passwords#new
        edit_admin_password GET    /admins/password/edit(.:format)    admin/passwords#edit
             admin_password PATCH  /admins/password(.:format)         admin/passwords#update
                            PUT    /admins/password(.:format)         admin/passwords#update
                            POST   /admins/password(.:format)         admin/passwords#create
  cancel_admin_registration GET    /admins/cancel(.:format)           admin/registrations#cancel
     new_admin_registration GET    /admins/sign_up(.:format)          admin/registrations#new
    edit_admin_registration GET    /admins/edit(.:format)             admin/registrations#edit
         admin_registration PATCH  /admins(.:format)                  admin/registrations#update
                            PUT    /admins(.:format)                  admin/registrations#update
                            DELETE /admins(.:format)                  admin/registrations#destroy
                            POST   /admins(.:format)                  admin/registrations#create
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lets make logged in home pages (for the user and admin)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails g controller users/home index --no-helper --no-assets --no-controller-specs --no-view-specs
rails g controller admins/home index --no-helper --no-assets --no-controller-specs --no-view-specs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now lets update our routes to ponit to these pages if the user is logged in add the following belos the deivse_for commands&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rails.application.routes.draw do
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
  # http://localhost:3000/umdzes/sign_in
  devise_for :umdzes, path: &#39;umdzes&#39;,
                      controllers: {
                        sessions:      &#39;umdzes/devise/sessions&#39;,
                        passwords:     &#39;umdzes/devise/passwords&#39;,
                        registrations: &#39;umdzes/devise/registrations&#39;
                      }
  # http://localhost:3000/patrons/sign_in
  devise_for :patrons,  path: &#39;patrons&#39;,
                      controllers: {
                        sessions:      &#39;patrons/devise/sessions&#39;,
                        passwords:     &#39;patrons/devise/passwords&#39;,
                        registrations: &#39;patrons/devise/registrations&#39;
                      }

  authenticated :patron do
    root &#39;patrons/home#index&#39;,     as: :auth_patron_root
  end
  authenticated :umdze do
    root &#39;umdzes/home#index&#39;,      as: :auth_umdze_root
  end
  authenticated :admin do
    root &#39;admins/home#index&#39;, as: :auth_admin_root
  end


  namespace :admins do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/admins&#39;, to: &#39;admins/home#index&#39;, as: :admins

  namespace :umdzes do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/umdzes&#39;, to: &#39;umdzes/home#index&#39;, as: :umdzes

  namespace :patrons do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/patrons&#39;, to: &#39;patrons/home#index&#39;, as: :patrons

  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  get &#39;landing/index&#39;
  root to: &amp;quot;landing#index&amp;quot;
end

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-make-applicationcontrollers-for-each-namespace--enforce-authentication&#34;&gt;now lets make ApplicationControllers for each namespace &amp;amp; enforce authentication&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;touch app/controllers/admins/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/admins/application_controller.rb
class Admins::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_admin!

  private

  def this_user
    current_admin
  end
end
EOF

touch app/controllers/umdzes/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/umdzes/application_controller.rb
class Umdzes::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_umdze!, unless: :allowed_access

  private

  def allowed_access
    current_admin
  end

  def this_user
    current_umdze || current_admin
  end
end
EOF

touch app/controllers/patrons/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/patrons/application_controller.rb
class Patrons::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_patron!, unless: :allowed_access

  private
  def allowed_access
    current_umdze || current_admin
  end

  def this_user
    current_patron || current_umdze || current_admin
  end
end
EOF

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;now-we-will-inhert-from-these-new-controllers-and-enforce-limits&#34;&gt;now we will inhert from these new controllers and enforce limits&lt;/h1&gt;
&lt;p&gt;now lets require these pages to have authenticated the correct user type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/controllers/admins/home_controller.rb
class Admins::HomeController &amp;lt; Admins::ApplicationController
  def index
  end
end

# app/controllers/umdzes/home_controller.rb
class Umdzes::HomeController &amp;lt; Umdzes::ApplicationController
  def index
  end
end

# app/controllers/patrons/home_controller.rb
class Patrons::HomeController &amp;lt; Patrons::ApplicationController
  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-prevent-student-and-admin-accounts-from-cross-visits-during-testing-or-whatever&#34;&gt;Now prevent student and admin accounts from cross visits (during testing, or whatever)&lt;/h2&gt;
&lt;p&gt;create this new file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch app/controllers/concerns/accessible.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/concerns/accessible.rb
module Accessible
  extend ActiveSupport::Concern
  included do
    before_action :check_user
  end

  protected
  def check_user
    if current_admin
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_admin_root_path) and return
    elsif current_umdze
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_umdze_root_path) and return
    elsif current_patron
      flash.clear
      # The authenticated user root path can be defined in your routes.rb in: devise_scope :user do...
      redirect_to(auth_partron_root_path) and return
    end
  end
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;use-this-accessible-concern&#34;&gt;use this accessible concern&lt;/h2&gt;
&lt;p&gt;Now add &lt;code&gt;include Accessible&lt;/code&gt; in the appropriate controllers:&lt;/p&gt;
&lt;p&gt;Note:
You must skip_before_action for the destroy action in each SessionsController to prevent the redirect to happen before the sign out occurs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# eg. ../controllers/admins/sessions_controller.rb
class Admins::SessionsController &amp;lt; Devise::SessionsController
 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/admins/registrations_controller.rb
You must also skip_before_action for the edit, update, destroy, and cancel actions in each RegistrationsController to allow current users to edit and cancel their own accounts. Otherwise they will be redirected before they can reach these pages.

class Admins::RegistrationsController &amp;lt; Devise::RegistrationsController
 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/umdzes/sessions_controller.rb
class Umdzes::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/umdzes/registrations_controller.rb
class Umdzes::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/patrons/sessions_controller.rb
class Patrons::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/patrons/registrations_controller.rb
class Patrons::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-give-the-patron-account-a-usernames&#34;&gt;now lets give the patron account a usernames&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rails generate migration add_username_to_patrons username:string:uniq
rails generate migration add_umdzes_name_to_umdzes fullname:string
rails generate migration add_admins_name_to_admins fullname:string

# now update the new migration to look like:
class AddUsernamToPatrons &amp;lt; ActiveRecord::Migration[6.0]
  def change
    # username is key not email - in fact we don&#39;t want an email
    rename_column :patrons, :email, :username
  end
end

class AddFullnameToUmdzes &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :umdzes, :umdzes_name, :string, null: false
  end
end

class AddFullnameToAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :admins, :admins_name, :string, null: false
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;update-the-models&#34;&gt;update the models&lt;/h2&gt;
&lt;p&gt;now we need to go to the models and make the following updates:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/models/admin.rb
class Admin &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :admins_name, presence: true
end

# app/models/umdze.rb
class Umdze &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :umdzes_name, presence: true
end


# app/models/patrons.rb
class Patron &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable, # :recoverable
          :authentication_keys =&amp;gt; [:username]

  validates :username, uniqueness: true
  # make the email field optional
  # validates :email, uniqueness: true

  def email_required?
    false
  end

  def email_changed?
    false
  end

  # use this instead of email_changed? for Rails = 5.1.x
  def will_save_change_to_email?
    false
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we can safely migrate &lt;code&gt;bundle exec rails db:migrate&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;lets-test-our-logins&#34;&gt;lets test our logins&lt;/h2&gt;
&lt;p&gt;lets create some common feature test code:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&#34;&gt;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&lt;/a&gt;
&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/support/features/session_helpers.rb
module Features
  module SessionHelpers
    # def patron_sign_up(username:, password:)
    #   visit new_patron_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Username&#39;, with: username
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def patron_log_in(patron = nil)
      patron = FactoryBot.create :patron if patron.nil?
      visit new_patron_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Username&#39;, with: patron.username
      fill_in &#39;Password&#39;, with: patron.password
      click_on &#39;Log in&#39;
    end

    # def umdze_sign_up(email:, password:)
    #   visit new_umdze_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def umdze_log_in(umdze = nil)
      umdze = FactoryBot.create :umdze if umdze.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end

    # def admin_sign_up(email:, password:)
    #   visit new_admin_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def admin_log_in(admin = nil)
      admin = FactoryBot.create :admin if admin.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are not allowing registrations, so that code is commented out.  However, we see we must configure our factories for this code to work.&lt;/p&gt;
&lt;p&gt;Lets tell rspec how to access this code in feature tests:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/support/features.rb
RSpec.configure do |config|
  config.include Features::SessionHelpers, type: :feature
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-create-test-for-our-devise-model-factories&#34;&gt;Lets create test for our devise model factories:&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# spec/models/patron_spec.rb
require &#39;rails_helper&#39;

RSpec.describe User, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end

# spec/models/admin_spec.rb
require &#39;rails_helper&#39;

RSpec.describe Admin, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these fail - run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to configure the factories so all is working:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/factories/patrons.rb
FactoryBot.define do
  factory :user do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow&#39; }
    password_confirmation { &#39;LetM3-InNow&#39; }
    # enable this if using confirmable
    # confirmed_at { Date.today }
  end
end

# spec/factories/umdzes.rb
FactoryBot.define do
  factory :umdze do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    umdzes_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

# spec/factories/admins.rb
FactoryBot.define do
  factory :admin do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    admins_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these pass now - run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we are ready to test devise and our restricted access to the users home page:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.madetech.com/blog/feature-testing-with-rspec&#34;&gt;https://www.madetech.com/blog/feature-testing-with-rspec&lt;/a&gt;
&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;
&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&lt;/a&gt;
&lt;a href=&#34;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&#34;&gt;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&lt;/a&gt;
&lt;a href=&#34;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&#34;&gt;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/features/users/user_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  # note user is NOT created in DB!
  let(:user)  { FactoryBot.build :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user is not signed-up&#39; do
    scenario &#39;user signs-up on registration page&#39; do
      user_sign_up(email: user.email, password: user.password)
      expect(current_path).to eql(users_home_path)
    end
  end
end


# spec/features/users/user_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  let(:user)  { FactoryBot.create :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user logs in successfully&#39; do
    scenario &#39;and is redirected to user home page&#39; do
      user_log_in(user)
      expect(current_path).to eql(auth_user_root_path)
    end
  end
end


# spec/features/users_home_page_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  let(:user)    { FactoryBot.create :user }
  after :each do
    # force a logout (clear warden info) after each test
    Warden.test_reset!
  end
  describe &#39;user is not authenticated&#39; do
    scenario &#39;user is redirected to user login before access to user home&#39; do
      visit users_home_path
      expect(current_path).to eql(new_user_session_path)
    end
  end
  describe &#39;user is already authenticated&#39; do
    before    { user_log_in(user) }
    scenario &#39;user gets direct access to the user homepage&#39; do
      visit users_home_path
      expect(page).to have_current_path(users_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and test to be sure admin can log in too:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/features/admins/admin_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  after :each do
    Warden.test_reset!
  end
  scenario &#39;logs in successfully and is redirected to user home page&#39; do
    admin_log_in
    expect(current_path).to eql(auth_admin_root_path)
  end
end


# spec/features/admins/admin_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admin Signup&#39;, type: :feature do
  # IMPORTANT is NOT created in DB!
  let(:admin)  { FactoryBot.build :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;admin is not signed-up&#39; do
    scenario &#39;admin registers&#39; do
      admin_sign_up(email: admin.email, password: admin.password)
      expect(page).to have_current_path(admins_home_path)
    end
  end
end


# spec/features/admins/admins_home_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admins Home&#39;, type: :feature do
  let(:admin)  { FactoryBot.create :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;un-authenticated&#39; do
    scenario &#39;attempts to access admins home page is redirected to user login&#39; do
      visit admins_home_path
      expect(current_path).to eql(new_admin_session_path)
    end
  end
  describe &#39;already authenticated&#39; do
    before    { admin_log_in(admin) }
    scenario &#39;gets access to the user homepage&#39; do
      visit admins_home_path
      expect(current_path).to eql(admins_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;before we wrap up - we need to fix our request specs - now that we added login restrictions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# spec/requests/users/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Patron::Homes&amp;quot;, type: :request do

  let(:patron)   { FactoryBot.create :patron }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;patron_home_path&#39; page is NOT accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in patron
      end
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;patrons_home_path&#39; page is accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/umdze/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Umdze::Homes&amp;quot;, type: :request do
  let(:umdze)   { FactoryBot.create :umdze }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is NOT accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in umdze
      end
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/admins/dashboard_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Admins::Dashboards&amp;quot;, type: :request do

  let(:admin)   { FactoryBot.create :admin }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      it &amp;quot;home as &#39;/admins&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is NOT accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in admin
      end
      after do
        sign_out admin
      end
      it &amp;quot;home as &#39;/admins&#39; page is accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run the tests and be sure all is green - if so, now is a good time to make a commit!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;rspec and devise configured and tests green&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
