<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Authentication | btihen</title>
    <link>https://btihen.me/tags/authentication/</link>
      <atom:link href="https://btihen.me/tags/authentication/index.xml" rel="self" type="application/rss+xml" />
    <description>Authentication</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© 2021</copyright><lastBuildDate>Wed, 22 Sep 2021 16:09:57 +0200</lastBuildDate>
    <image>
      <url>https://btihen.me/img/btihen_landing_page.png</url>
      <title>Authentication</title>
      <link>https://btihen.me/tags/authentication/</link>
    </image>
    
    <item>
      <title>Rails 6.x Auth with MagicLink using SecureRandom Token</title>
      <link>https://btihen.me/post_ruby_rails/rails_6_x_auth_w_magic_links_using_random_token/</link>
      <pubDate>Wed, 22 Sep 2021 16:09:57 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/rails_6_x_auth_w_magic_links_using_random_token/</guid>
      <description>&lt;p&gt;Passwordless Authentication is very convenient for users and generally as secure as passwords (according to many articles as long as the email access-links are short-lived - as email is not very secure).&lt;/p&gt;
&lt;p&gt;Therefore, after some reading, it seems like a good approach is to make a short-lived link, and then transfer the security to a session.&lt;/p&gt;
&lt;p&gt;I found that there seems to be three simple approaches:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Do it yourself: with a Signed-GlobalID from Rails (self-times out &amp;amp; no migration)&lt;/li&gt;
&lt;li&gt;Do it yourself: with a Stored-Token (adapts to any framework)&lt;/li&gt;
&lt;li&gt;Other Options: Devise Plugin (when using devise) or other Gems&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This article will focus on using Secure Random - since it can work with any Framework (in Rails however, I prefer to use SignedGlobalIDs - see: 
&lt;a href=&#34;https://btihen.me/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://btihen.me/&lt;/a&gt; , since it simplifies the user model and the expiration logic)&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;User enters their email-address in a simple form&lt;/li&gt;
&lt;li&gt;If account is found - a link with a token is generated and email is sent&lt;/li&gt;
&lt;li&gt;User is notified that the link is on its way (even if the account is not found and no email is sent)&lt;/li&gt;
&lt;li&gt;When the user follows the link in the email, a session is generated&lt;/li&gt;
&lt;li&gt;Session valid until the session expires or the user logs out (deleting the session).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; I will be assuming that the account must exist, but you could also just create a new account &lt;em&gt;(consider this option carefully and some limits on account creation per IP address or per hour, etc.  As you could otherwise be flooded with useless, malicious emails!)&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;do-it-yourself&#34;&gt;Do it yourself&lt;/h2&gt;
&lt;p&gt;This is relatively easy to do with built-in Rails security - and I like not being dependent on external code, I&amp;rsquo;ll show a way to do this.  In this case, assume that the accounts are already created (or not).&lt;/p&gt;
&lt;p&gt;If you want to do user registration, confirmation, etc &amp;ndash; then I think it is best to use Devise or some other gem!&lt;/p&gt;
&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;Code repo is posted at: 
&lt;a href=&#34;https://github.com/btihen/magic_token&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/btihen/magic_token&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Create a Rails Project:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails new magic_token
cd magic_token
bin/rails db:create
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now start rails and be sure you get the welcome page at:
&lt;code&gt;http://localhost:3000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Assuming all works well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-a-landing-page&#34;&gt;Create a Landing Page&lt;/h3&gt;
&lt;p&gt;We will now make a landing page (it will need to be always available):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g controller landing index --helper false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now lets point the root page to that too - make the routes page look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets check all is well with the routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails routes | grep landing
# should show
  landing   GET   /landing(:format)   landing#index
     root   GET   /                   landing#index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(quite likely it will be all spread out)&lt;/p&gt;
&lt;p&gt;Start up rails and be sure we can access these pages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://localhost:3000/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://localhost:3000/landing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Feel free to make them look nicer!&lt;/p&gt;
&lt;p&gt;assuming all works well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;add landing page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-users-management-page&#34;&gt;Create Users Management Page&lt;/h3&gt;
&lt;p&gt;User-Controller to manage users:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g scaffold User email:string token:string token_expires_at:datetime --helper false
bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets make a few accounts in the seed file (or enter in the console &lt;code&gt;bin/rails c&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# db/seeds.rb
User.create(email: &#39;test1@test.ch&#39;)
User.create(email: &#39;test2@test.ch&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now run the seed file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:seed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets start Rails&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go to: &lt;code&gt;http://localhost:3000/users&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now you should see the users &amp;amp; be able to create a few more users.&lt;/p&gt;
&lt;p&gt;Feel free to make the GUI nicer!&lt;/p&gt;
&lt;p&gt;Assuming all is good:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;user management page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;add-auth-restrictions-to-application-controller&#34;&gt;Add auth restrictions to Application Controller&lt;/h3&gt;
&lt;p&gt;This will allow us to control access to all urls within our app (we will also allow exceptions for a landing page)&lt;/p&gt;
&lt;p&gt;The application controller ensures only authenticated users (with a session) can access pages - with the following code (especially the &lt;code&gt;users_only&lt;/code&gt;, but current_user is also very helpful generally)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/application_controller.rb
class ApplicationController &amp;lt; ActionController::Base
  before_action :users_only

  def current_user
    # `dig` and `find_by` avoid raising an exception w/o a session
    user_id = session.dig(:user_id)
    @current_user ||= User.find_by(id: user_id)
  end

  private

  # code to ensure only logged in users have access to users pages
  def users_only
    if current_user.blank?
      # send to login page to get an access link
      redirect_back(fallback_location: landing_path,
                    :alert =&amp;gt; &amp;quot;Login Required&amp;quot;)
      # # uncomment to send people access link page (when built)
      # redirect_back(fallback_location: new_login_path,
      #               :alert =&amp;gt; &amp;quot;Login Required&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we should NOT be able to reach our previous pages&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:3000/&lt;/code&gt;
&lt;code&gt;http://localhost:3000/users&lt;/code&gt;
&lt;code&gt;http://localhost:3000/landing&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now lets allow access to the landing page again - we need to add:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;skip_before_action :users_only&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;to &lt;code&gt;app/controllers/landing_controller.rb&lt;/code&gt; in order to allow unathenticated access.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/landing_controller.rb
class LandingController &amp;lt; ApplicationController
  skip_before_action :users_only
  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming that works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;restrict access w/exception&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-a-users-homepage&#34;&gt;Create a Users Homepage&lt;/h3&gt;
&lt;p&gt;Now that we have a public home / default page - lets make an authenticed (user) homepage - where we auto-redirect people on login.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g controller home index --helper false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update the routes page with the following (I&amp;rsquo;m not a fan of including the &lt;code&gt;index&lt;/code&gt; in the url)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  get &#39;/home&#39;,    to: &#39;home#index&#39;,     as: :home
  resources :users
  get &#39;/landing&#39;, to: &#39;landing#index&#39;,  as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets check all is well with the routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails routes | grep home
# should show
  home  GET   /home(:format)    home#index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming the routes are correct when we try to go to:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:3000/home&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;we should end up at (be redirected to):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:3000/landing&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;assuming this works well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;restricted user home page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;optional---setup-a-mail-trap-mailhog&#34;&gt;Optional - setup a mail trap (MailHog)&lt;/h3&gt;
&lt;p&gt;I like to view the emails in a browser to check the look as well as the content, for this quick blog - just viewing the info in the logs is good enough.  However, in case you are interested a quick mini MailHog tutorial (for a Mac):&lt;/p&gt;
&lt;p&gt;Install mailhog:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install mailhog
mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now open &lt;code&gt;config/environments/development.rb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and add the following mail settings (for development):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/development.rb
Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.
  # ...
  # mailhog config
  config.action_mailer.perform_deliveries = true
  config.action_mailer.smtp_settings = { address: &#39;localhost&#39;, port: 1025 }
  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;at this point you will be able to go to: &lt;code&gt;http://localhost:8025/&lt;/code&gt; and you should see a webpage that looks like a simple mailreader.  In the future, when you send an email from rails it should be available here.&lt;/p&gt;
&lt;h3 id=&#34;create-an-emailer-to-send-access-links&#34;&gt;Create an emailer to send Access-Links&lt;/h3&gt;
&lt;p&gt;We need a way to send the login link - so we will create a login mailer with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails generate mailer Login send_link --helper false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configure our emailer for our needs to send the login link:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/mailer/login_mailer.rb
class LoginMailer &amp;lt; ApplicationMailer
  def send_link(user, login_url)
    @user = user
    @login_url  = login_url
    host = Rails.application.config.hosts.first

    mail(to: @user.email, subject: &amp;quot;Access-Link for #{host}&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to create the mailer views to send the url with the access token&lt;/p&gt;
&lt;p&gt;The HTML view:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/views/login_mailer/send_link.html.erb
&amp;lt;h1&amp;gt;Hi &amp;lt;%= @user.email %&amp;gt;,&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;&amp;lt;%= @login_url %&amp;gt;&amp;quot;&amp;gt;Access-Link for &amp;lt;%= @host %&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt; &amp;lt;%= @login_url %&amp;gt; &amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;Link is valid for about an hour from &amp;lt;%= DateTime.now %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The text view:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/views/login_mailer/send_link.text.erb
Hi &amp;lt;%= @user.email %&amp;gt;,

Access-Link for &amp;lt;%= @host %&amp;gt; is:

&amp;lt;%= @login_url %&amp;gt;

Link is valid for about an hour from &amp;lt;%= DateTime.now %&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again feel free to make these pages more beautiful with CSS (Bulma or Tailwind are my favorites)&lt;/p&gt;
&lt;p&gt;Lets test our mailer with the rail console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c

# for testing we don&#39;t care much which user we pick
user = User.first
# we will just send a &#39;fake url&#39; - we are just testing our mail sending
url  = &amp;quot;http://localhost:3000/landing&amp;quot;

# we should should now be able to send the mail with:
LoginMailer.send_link(user, url).deliver_later
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you should be able to see that the mail was send from the console output or by going to: &lt;code&gt;http://localhost:8025/&lt;/code&gt; if you are running mailhog and see the email sent.&lt;/p&gt;
&lt;p&gt;Assuming that work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;Login URL mailer&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-an-session-authorization-controller&#34;&gt;Create an Session Authorization Controller&lt;/h3&gt;
&lt;p&gt;For the session controller we don&amp;rsquo;t need views or anything else so we can just create the controller file directly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch app/controllers/sessions_controller.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SessionsController &amp;lt; ApplicationController
  skip_before_action :users_only, only: :create

  def create
    token = params[:token].to_s
    # find the user with a matching token and with current-time &amp;lt; token_expired_at
    user = User.where(token: token)
               .where(&#39;users.token_expires_at &amp;gt; (?)&#39;, DateTime.now)
               .first
    if user
      # create the session id for current_user to access
      session[:user_id] = user.id
      # send the user to their homepage (or where erver you prefer)
      redirect_to(home_path, notice: &amp;quot;Welcome back #{user.name}&amp;quot;)
    else
      flash[:alert] = &#39;Oops - a valid login link is required&#39;
      redirect_to(landing_path)
      # when the login request page is built it might make sense to redirect to:
      # redirect_to(new_login_path)
    end
  end

  # allow a user to logout / destroy session if desired
  def destroy
    user = current_user
    if user
      session[:user_id] = nil
      flash[:notice] = &amp;quot;logout successful&amp;quot;
    else
      falsh[:alert] = &amp;quot;Oops, there was a problem&amp;quot;
    end
    redirect_to(landing_path)
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add to routes (I am using a get for the create instead of a post verb - since I don&amp;rsquo;t know of a way to make a text url embed a post verb) - so we will add:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  get &#39;/sessions/:token&#39;, to: &#39;sessions#create&#39;,  as: :create_session
  resources :sessions,    only: [:destroy]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to the routes file:&lt;/p&gt;
&lt;p&gt;Now the routes should look something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  # use get to create since I don&#39;t think a text url can create a post
  get &#39;/sessions/:token&#39;, to: &#39;sessions#create&#39;,  as: :create_session
  resources :sessions,    only: [:destroy]
  get &#39;/home&#39;,    to: &#39;home#index&#39;,     as: :home
  resources :users
  get &#39;/landing&#39;, to: &#39;landing#index&#39;,  as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now if we check the session routes we should see something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails routes | grep session
  create_session    GET     /sessions/:token(.:format)   sessions#create
         session    DELETE  /sessions/:id(.:format)      sessions#destroy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;OPTIONAL:&lt;/strong&gt; by default rails sessions have no expiration, thus are deleted when the browser closes. To change this default behavior, we need to create the file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch config/initializers/session_store.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can set the session length (time until a new login is required) with the setting:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/session_store.rb
Rails.application.config.session_store :cookie_store, expire_after: 14.days
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you might want to use 2 weeks or 4 weeks - whatever you and your users are comfortable with before forcing a new login (if unsure - go with a shorter time-frame)&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s setup a user with a known valid token and test our new session controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c

user = User.first
# the token length isn&#39;t so important but should be enough to make guessing very hard
user.token = SecureRandom.hex(50)  # be sure to use a url-safe random-generator
# expiration time should be relatively short - email is generally not encrypted
user.token_expires_at = DateTime.now + 1.hour
user.save
user.reload

# generate the URL for the session path
# (we need to give the full rails path to the url_helpers since we don&#39;t have the controller loaded)
url = Rails.application.routes.url_helpers.create_session_url(token: user.token, host: &#39;localhost:3000&#39;)

# copy the above url into the browser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when we enter the url generated in the email (or click on the link in mailhog), we should be redirected to the &amp;ldquo;home&amp;rdquo; page &lt;code&gt;http://localhost:3000/home&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Assumeing that works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;session controller (login)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;access-link-generation&#34;&gt;Access-Link Generation&lt;/h3&gt;
&lt;p&gt;We will need to allow the user to request an access-link.&lt;/p&gt;
&lt;h4 id=&#34;login-controller&#34;&gt;Login Controller&lt;/h4&gt;
&lt;p&gt;Now lets create a user login controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g controller Logins new create --helper false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need the Logins Controller login AND be sure to add&lt;/p&gt;
&lt;p&gt;&lt;code&gt;skip_before_action :users_only&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;so this page is always available!&lt;/p&gt;
&lt;p&gt;Also note the code is similar to what we entered previously in the console.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/users/logins_controller.rb
class LoginsController &amp;lt; ApplicationController
  # we need to skip the users only check so this pages can be accessed
  skip_before_action :users_only

  def new
    user = User.new
    render :new, locals: {user: user}
  end

  def create
    email = user_params[:email]

    # we may or may not find a user
    user = User.find_by(email: email)

    # always take the time to calculate token info (discourages email fishing)
    token = SecureRandom.hex(50)
    # besure to use NOW and not NEW!
    token_expires_at = DateTime.now + 1.hour
    token_params = {token: token, token_expires_at: token_expires_at}

    # if we have a user and the update is successful
    if user &amp;amp;&amp;amp; user.update(token_params)
      access_url = create_session_url(token: user.token)
      LoginMailer.send_link(user, access_url).deliver_later
    end

    # # uncomment to add noise to discourage response time monitoring
    # # in order to mine user emails
    # mini_wait = Random.new.rand(10..20) / 1000
    # wait(mini_wait)

    # true or not we state we have sent an access link and redirect to the landing page
    # also prevent email fishing by always returning the same answer
    redirect_to(landing_path, notice: &amp;quot;Access-Link has been sent&amp;quot;)
  end

  private
    # Only allow a list of trusted parameters through.
    def user_params
      params.require(:user).permit(:email)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;  In real projects I tend to put all my business logic in a &lt;code&gt;command&lt;/code&gt; or &lt;code&gt;service&lt;/code&gt; class &amp;ndash; I like skinny models and skinny controllers)&lt;/p&gt;
&lt;p&gt;We need to add the route to the users login_controller with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  resources :logins,      only: [:new, :create]
  # use get to create since I don&#39;t think a text url can create a post
  get &#39;/sessions/:token&#39;, to: &#39;sessions#create&#39;,  as: :create_session
  resources :sessions,    only: [:destroy]
  get &#39;/home&#39;,    to: &#39;home#index&#39;,     as: :home
  resources :users
  get &#39;/landing&#39;, to: &#39;landing#index&#39;,  as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now check the routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails routes | grep logins
# should return
     logins   POST  /logins(.:format)       logins#create
  new_login   GET   /logins/new(.:format)   logins#new
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets go to the new page &lt;code&gt;http://localhost:3000/logins/new&lt;/code&gt; and be sure that we can get access that page.&lt;/p&gt;
&lt;p&gt;Now login into the console and check the user attributes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c
user = User.find_by(email: &#39;test1.test.ch&#39;) # or whatever email you used
user.token # be sure it updated with the same key as in the logs
user.token_expires_at # should be an hour into the future
# if the date is the year 0000 - then you used .new (with an `e`) instead of .now
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming this works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;login controller&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;login-form&#34;&gt;Login Form&lt;/h4&gt;
&lt;p&gt;Login email form - we only need &lt;code&gt;app/views/logins/new.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We can delete &lt;code&gt;app/views/logins/create.html.erb&lt;/code&gt; as that just posts to an action and then redirects to our user&amp;rsquo;s home_path&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/views/ogins/new.html.erb
&amp;lt;%= form_for(user, local: true,
             url: logins_path, # NEW MUST BE PLURAL for POST
             id: &amp;quot;login-form&amp;quot;, class: &amp;quot;user&amp;quot; ) do |form|  %&amp;gt;

  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;label class=&amp;quot;label&amp;quot;&amp;gt;Email for Access-Link&amp;lt;/label&amp;gt;
    &amp;lt;div class=&amp;quot;control&amp;quot;&amp;gt;
      &amp;lt;%= form.email_field :email,
                            placeholder: &amp;quot;Email&amp;quot;,
                            class: &#39;input&#39; %&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;p class=&amp;quot;help&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;control&amp;quot;&amp;gt;
    &amp;lt;%= form.submit(&amp;quot;Get Access-Link&amp;quot;, class: &amp;quot;button is-success&amp;quot;) %&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PS - I dislike using instance variables (and often use &amp;lsquo;input&amp;rsquo; classes) with my forms - this is why this form looks a little different than standard rails.&lt;/p&gt;
&lt;p&gt;Note I often use Bulma - so here is how I like to format my forms (without Bulma installed the form will be ugly).&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s test this code:&lt;/p&gt;
&lt;p&gt;First:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go to: &lt;code&gt;http:localhost:3000/home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;hopefully your are redirected to: &lt;code&gt;http:localhost:3000/landing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go to: &lt;code&gt;http:localhost:3000/logins/new&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;enter a user&amp;rsquo;s email address&lt;/li&gt;
&lt;li&gt;find the login url generated in the email&lt;/li&gt;
&lt;li&gt;enter that login_url in the browser - (ideally click on the link in mailhog - much like a &amp;lsquo;real user&amp;rsquo; would do)&lt;/li&gt;
&lt;li&gt;hopefully you are now redirected to &lt;code&gt;http:localhost:3000/home&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assuming this works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;login form and create action with redirect&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;s
Code Repository is at:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rails GlobalID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The nice thing about these is that the auto expire - simplifying the code and the usermodel.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/rails/globalid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/rails/globalid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.magicalruby.com/implementing-magic-links-in-rails/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.magicalruby.com/implementing-magic-links-in-rails/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Token using SecureRandom&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With these you need to create your own expiration and lookup system (more code add a migration), but will work with any framework.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(using uuids) - 
&lt;a href=&#34;https://oozou.com/blog/how-to-implement-passwordless-authentication-in-ruby-on-rails-154&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://oozou.com/blog/how-to-implement-passwordless-authentication-in-ruby-on-rails-154&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(using SecureRandom) - 
&lt;a href=&#34;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Devise Options&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Devise Plugin - 
&lt;a href=&#34;https://github.com/abevoelker/devise-passwordless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/abevoelker/devise-passwordless&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do it Yourself Devise - 
&lt;a href=&#34;https://dev.to/matiascarpintini/magic-links-with-ruby-on-rails-and-devise-4e3o&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/matiascarpintini/magic-links-with-ruby-on-rails-and-devise-4e3o&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do it yourself Devise - 
&lt;a href=&#34;https://www.mintbit.com/blog/passwordless-authentication-in-ruby-on-rails-with-devise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.mintbit.com/blog/passwordless-authentication-in-ruby-on-rails-with-devise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Other Options&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;passwordless gem - 
&lt;a href=&#34;https://github.com/mikker/passwordless#token-and-session-expiry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/mikker/passwordless#token-and-session-expiry&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;magic-link gem - 
&lt;a href=&#34;https://github.com/dvanderbeek/magic-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/dvanderbeek/magic-link&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using Sorcery - 
&lt;a href=&#34;https://fullstackheroes.com/rails/sorcery-passwordless-authentication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fullstackheroes.com/rails/sorcery-passwordless-authentication/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using Sourcery - 
&lt;a href=&#34;https://www.sitepoint.com/magical-authentication-sorcery/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.sitepoint.com/magical-authentication-sorcery/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(using JWTs) - 
&lt;a href=&#34;https://blog.kiprosh.com/implement-passwordless-authentication-via-magic-link-in-rails-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.kiprosh.com/implement-passwordless-authentication-via-magic-link-in-rails-api/&lt;/a&gt;
&lt;strong&gt;Passwordless Security Overview&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Sessions&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://blog.saeloun.com/2019/09/12/rails-6-adds-dig-to-actiondispatch-request-session.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.saeloun.com/2019/09/12/rails-6-adds-dig-to-actiondispatch-request-session.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rails 6.x&#43; Auth with MagicLinks using Rails Signed GlobalIDs</title>
      <link>https://btihen.me/post_ruby_rails/rails_6_x_auth_w_magic_links_using_signed_global_id/</link>
      <pubDate>Sun, 19 Sep 2021 01:36:55 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/rails_6_x_auth_w_magic_links_using_signed_global_id/</guid>
      <description>&lt;p&gt;Passwordless Authentication is very convenient for users and generally as secure as passwords (a good security authentication discussion can be found at: ).&lt;/p&gt;
&lt;p&gt;A good approach is to make a short-lived link, and then transfer the security to a session.&lt;/p&gt;
&lt;p&gt;I found that there seems to be three simple approaches:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Do it yourself: with a Stored-Token (with an expiration date-time)&lt;/li&gt;
&lt;li&gt;Do it yourself: with a Signed-GlobalID from Rails (self-times out &amp;amp; no stored tokens)&lt;/li&gt;
&lt;li&gt;Other Options: other Gems for Devise, Sorcery, or independent gems&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;User enters their email-address in a simple form&lt;/li&gt;
&lt;li&gt;If account is found - a link with a token is generated and email is sent&lt;/li&gt;
&lt;li&gt;User is notified that the link is on its way (even if the account is not found and no email is sent)&lt;/li&gt;
&lt;li&gt;When the user follows the link in the email, a session is generated&lt;/li&gt;
&lt;li&gt;Session valid until the session expires or the user logs out (deleting the session).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; User accounts are assumed to be previously created, and verified.  If you need a full set of features - then your best option is probably to use devise, sorcery or authenticate and use an extension or build your own extension to one of these libraries.  Either way, this article will clarify the basics of passwordless authentication.&lt;/p&gt;
&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;Code Repo is posted at: 
&lt;a href=&#34;https://github.com/btihen/magic_sgid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/btihen/magic_sgid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Create a Rails Project&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails new magic_id
cd magic_id
git add .
git commit -m &amp;quot;initial commit on creation&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;User-Controller to manage users:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:create
bin/rails g scaffold User name:string email:string
bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets start Rails&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go to: &lt;code&gt;http://localhost:3000/users&lt;/code&gt; and create a few users - feel free to make the GUI nicer!&lt;/p&gt;
&lt;p&gt;Assuming all is good:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit &amp;quot;user management scaffold&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-a-landing-page&#34;&gt;Create a Landing Page&lt;/h3&gt;
&lt;p&gt;we need a landing / root page to send users when they are not logged in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g controller landing index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now lets point the root page to that too - make the routes page look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I will also remove: &lt;code&gt;app/helpers/landing_helper.rb&lt;/code&gt; with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm app/helpers/landing_helper.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets check all is well with the routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails routes | grep landing
# should show
  landing GET /landing(:format) landing#index
     root GET /                 landing#index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(quite likely it will be all spread out)&lt;/p&gt;
&lt;p&gt;Now the following pages should be available:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://localhost:3000/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://localhost:3000/landing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;again feel free to make them look nice.&lt;/p&gt;
&lt;p&gt;assuming all works well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;create landing page and landing &amp;amp; root route&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-a-user-application-controller-restrict-access&#34;&gt;Create a User Application Controller (restrict access)&lt;/h3&gt;
&lt;p&gt;This will allow us to control access to all urls in the /users paths within our app&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir app/controllers/users
touch app/controllers/users/application_controller.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The application controller ensures only authenticated users (with a session) can access pages in the &lt;code&gt;users&lt;/code&gt; area:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/users/application_controller.rb
class Users::ApplicationController &amp;lt; ApplicationController
  before_action :users_only

  def current_user(user_id = session[:user_id])
    # `try` and `find_by` avoid raising an exception w/o a session
    @current_user ||= User.find_by(id: user_id)
  end

  private

  # code to ensure only logged in users have access to users pages
  def users_only
    # send person to a safe page if not logged in
    if current_user.blank?
      # send to login page to get an access link
      redirect_back(fallback_location: landing_path,
                    :alert =&amp;gt; &amp;quot;Login Required&amp;quot;)
      # once the below page is created we can redirect to here instead
      # redirect_back(fallback_location: new_users_login_path,
      #               :alert =&amp;gt; &amp;quot;Login Required&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOTE: if you want all pages protected then put this code in:
&lt;code&gt;app/controllers/application_controller.rb&lt;/code&gt;
and adjust the routes (remove the namespace)!&lt;/p&gt;
&lt;h3 id=&#34;restricted-user-home-page&#34;&gt;Restricted User Home Page&lt;/h3&gt;
&lt;p&gt;we need a landing / root page to send users when they are not logged in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g controller users/landing index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now lets point the root page to that too - make the routes page look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  namespace :users do
    get &#39;/&#39;,                as: &#39;root&#39;,         to: &#39;home#index&#39;
    get &#39;/home&#39;,            as: &#39;home&#39;,         to: &#39;home#index&#39;
  end
  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Update the controller to use the Users::ApplicationController:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/users/home_controller.rb
class Users::HomeController &amp;lt; Users::ApplicationController
  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I will also remove: &lt;code&gt;app/helpers/users/home_helper.rb&lt;/code&gt; with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm app/helpers/users/home_helper.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets check all is well with the routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails routes | grep user
# should show
  users_home GET /users/home(:format) home#index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(quite likely it will be all spread out)&lt;/p&gt;
&lt;p&gt;Now the following pages should NOT be available:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://localhost:3000/users&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://localhost:3000/users/home&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and we should be redirected to the landing page.  If you access the home page - then probably the first line is wrong it should be:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Users::HomeController &amp;lt; Users::ApplicationController&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;assuming all works well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;create restricted user home page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-an-session-authorization-controller&#34;&gt;Create an Session Authorization Controller&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch app/controllers/users/sessions_controller.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Users::SessionsController &amp;lt; Users::ApplicationController
  # before_action :users_only, only: :destroy
  skip_before_action :users_only, only: :create

  def create
    sgid_token = params[:token].to_s
    user = GlobalID::Locator.locate_signed(sgid_token, for: &#39;user_access&#39;)
    if user
      # create the session id for current_user to access
      session[:user_id] = user.id
      redirect_to(users_home_path, notice: &amp;quot;Welcome back #{user.name}&amp;quot;)
    else
      flash[:alert] = &#39;Oops - you need a new login link&#39;
      redirect_to(landing_path)
      # later when created we will redirect to login access link page
      # redirect_to(new_users_login)
    end
  end

  # allow a user to logout / destroy session if desired
  def destroy
    user = current_user
    if user
      session[:user_id] = nil
      flash[:notice] = &amp;quot;logout successful&amp;quot;
    else
      falsh[:alert] = &amp;quot;Oops, there was a problem&amp;quot;
    end
    redirect_to(landing_path)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add to routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  namespace :users do
    get &#39;/&#39;,                as: &#39;root&#39;,         to: &#39;home#index&#39;
    get &#39;/home&#39;,            as: &#39;home&#39;,         to: &#39;home#index&#39;
    # use get to create since I don&#39;t think a text url can create a post
    get &#39;/sessions/:token&#39;, as: &#39;session_create&#39;, to: &#39;sessions#create&#39;
    # allow logout / destroy the session
    resources :sessions,    only: [:destroy]
  end
  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To test this go to rails console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c
# create our own token
user = User.first
global_id = User.find(user.id).to_sgid(expires_in: 1.hour, for: &#39;user_access&#39;)
access_token = global_id.to_s

# check that this global_id works (we should get the same user)
GlobalID::Locator.locate_signed(access_token, for: &#39;user_access&#39;)

# add url helpers to console
include ActionView::Helpers
include ActionView::Helpers::UrlHelper
# generate the URL for the session
Rails.application.routes.url_helpers.users_session_create_url(token: global_id.to_s, host: &#39;locahost:3000&#39;)
# should get something like:
# &amp;quot;http://locahost:3000/users/sessions/BAh7CEkiCGdpZAY6BkVUSSItZ2lkOi8vbWFnaWMtbGlua3MvVXNlci8xP2V4cGlyZXNfaW49MzYwMAY7AFRJIgxwdXJwb3NlBjsAVEkiEHVzZXJfYWNjZXNzBjsAVEkiD2V4cGlyZXNfYXQGOwBUSSIdMjAyMS0wOS0xOVQxNTozNzo0MS4wNjdaBjsAVA==--c948a0a5ccbae391c7ab9c808677fe41da4cbc28&amp;quot;

# copy this url into the browser
# now we be on: `http://localhost:3000/user/` &amp;amp; `http://localhost:3000/user/home`

# if you try again in an hour it should not work!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; by default rails sessions have no expiration, thus are deleted when the browser closes. To change this default behavior, you can set the session length with the setting:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/session_store.rb
Rails.application.config.session_store :cookie_store, expire_after: 14.days
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming all works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;session controller gives access to users_home&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;access-link-generation&#34;&gt;Access-Link Generation&lt;/h3&gt;
&lt;p&gt;We will need to allow the user to request an access-link.  We will do this with (we won&amp;rsquo;t be generating any models just a controller and a submission form - scaffold_controller does this for us):&lt;/p&gt;
&lt;h4 id=&#34;create-a-mailer-to-send-access-links&#34;&gt;Create a Mailer to send Access-Links&lt;/h4&gt;
&lt;p&gt;We need a way to send the login link - so we will create a login mailer with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails generate mailer Login send_link
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configure our emailer for our needs with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class LoginMailer &amp;lt; ApplicationMailer
  def send_link(user, login_url)
    @user = user
    @login_url  = login_url
    host = Rails.application.config.hosts.first

    mail(to: @user.email, subject: &amp;quot;Access-Link for #{host}&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course set up the views that contain the contents of the email:
The HTML Version&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/views/login_mailer/send_link.html.erb
&amp;lt;h1&amp;gt;Hi &amp;lt;%= @user.name %&amp;gt;,&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;&amp;lt;%= @login_url %&amp;gt;&amp;quot;&amp;gt;Access-Link for &amp;lt;%= @host %&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt; &amp;lt;%= @login_url %&amp;gt; &amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;Link is valid for about an hour from &amp;lt;%= DateTime.now %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The text version:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/views/login_mailer/send_link.text.erb
Hi &amp;lt;%= @user.name %&amp;gt;,

Access-Link for &amp;lt;%= @host %&amp;gt; is:

&amp;lt;%= @login_url %&amp;gt;

Link is valid for about an hour from &amp;lt;%= DateTime.now %&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;setup-mailhog-optional&#34;&gt;Setup Mailhog (OPTIONAL)&lt;/h4&gt;
&lt;p&gt;This is optional - technical testing can be done from the log file - but to see what the email formatting looks like this is VERY HELPFUL.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install mailhog
mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configure Rails to send emails to port 1025 in development (where mailhog listens)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/development.rb
Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.
  # ...
  # mailhog config
  config.action_mailer.perform_deliveries = true
  config.action_mailer.smtp_settings = { address: &#39;localhost&#39;, port: 1025 }
  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now open - to view:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;open localhost:8025
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;
&lt;p&gt;Now lets create a user login controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch app/controllers/users/logins_controller.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the contents of the controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/users/logins_controller.rb
class Users::LoginsController &amp;lt; Users::ApplicationController
skip_before_action :users_only

  def new
    user = User.new
    render :new, locals: {user: user}
  end

  def create
    email = user_params[:email]
    ip_address = request.remote_ip
    # the participant might already exist in our db or possimagic_link_url = participants_session_auth_url(token: participant.login_token)bly a new participant
    user = User.find_by(email: email)

    if user
      # create a signed expiring Rails Global ID - this makes LONG tokens, but browswers can handle it
      # all browsers should handle up to 2000 characters.
      # https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
      # https://www.geeksforgeeks.org/maximum-length-of-a-url-in-different-browsers/
      global_id = user.to_sgid(expires_in: 1.hour, for: &#39;user_access&#39;)
      access_url = users_session_create_url(token: global_id.to_s)
      LoginMailer.send_link(user, access_url).deliver_later
    else
      # if user isn&#39;t found then grab a user and compute the global_id and url (but don&#39;t send an email)
      # in order to make the time of both paths similar - so people can&#39;t find user emails checking the response times
      # see: https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/

      global_id = User.first.to_sgid(expires_in: 1.hour, for: &#39;user_access&#39;)
      access_url = user_auth_url(token: global_id.to_s)
    end

    # uncomment to add noise to further make email fishing difficult to time
    # mini_wait = Random.new.rand(10..20) / 1000
    # wait(mini_wait)

    # true or not we state we have sent an access link and redirect to the landing page
    # also prevent email fishing by always returning the same answer
    redirect_to(landing_path, notice: &amp;quot;Access-Link has been sent&amp;quot;)
  end

  private

    # Only allow a list of trusted parameters through.
    def user_params
      params.require(:user).permit(:email)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; You can let the GlobalID be valid for however long you want (in hours), but since email isn&amp;rsquo;t very secure, it seems wise to keep this short lived.  The default time is 30.days&lt;/p&gt;
&lt;p&gt;We need to add the route to the users login_controller with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb
Rails.application.routes.draw do
  # restricted area (protected by user login - Users::ApplicationController)
  namespace :users do
    get &#39;/&#39;,                as: &#39;root&#39;,         to: &#39;home#index&#39;
    get &#39;/home&#39;,            as: &#39;home&#39;,         to: &#39;home#index&#39;
    # use get to create since I don&#39;t think a text url can create a post
    get &#39;/sessions/:token&#39;, as: &#39;session_create&#39;, to: &#39;sessions#create&#39;
    # allow logout / destroy the session
    resources :sessions,    only: [:destroy]
    # login (generates link and emails to the user)
    resources :logins,      only: [:new, :create]
  end
  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now check the routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails routes | grep users
# should return
     users_logins POST  /users/logins(.:format)     users/logins#create
  new_users_login GET   /users/logins/new(.:format) users/logins#new
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;email--access-link-form&#34;&gt;Email / Access Link form&lt;/h4&gt;
&lt;p&gt;Login email form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir app/views/users/logins
touch app/views/users/logins/new.html.erb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note I often use Bulma - so here is how I like to format my forms (without Bulma installed the form will be ugly).
Also note, I dislike using instance variables in my form - so this is why the form looks a little extra complicated.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/views/users/logins/new.html.erb
&amp;lt;%= form_for(user, local: true,
             url: users_logins_path,   # NEW MUST BE PLURAL for POST
             id: &amp;quot;user-login-form&amp;quot;, class: &amp;quot;user&amp;quot; ) do |form|  %&amp;gt;

  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;label class=&amp;quot;label&amp;quot;&amp;gt;Email for Access-Link&amp;lt;/label&amp;gt;
    &amp;lt;div class=&amp;quot;control&amp;quot;&amp;gt;
      &amp;lt;%= form.email_field :email,
                            placeholder: &amp;quot;Email&amp;quot;,
                            class: &#39;input&#39; %&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;p class=&amp;quot;help&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;control&amp;quot;&amp;gt;
    &amp;lt;%= form.submit(&amp;quot;Get Access-Link&amp;quot;, class: &amp;quot;button is-success&amp;quot;) %&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;test-the-full-flow&#34;&gt;Test the full flow&lt;/h2&gt;
&lt;p&gt;using the command line create some users:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c
User.create(email: &amp;quot;tester@test.ch&amp;quot;, name: &amp;quot;Tester&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;start rails with: &lt;code&gt;bin/rails s&lt;/code&gt;
start mailhog with: &lt;code&gt;mailhog&lt;/code&gt;
go to: &lt;code&gt;http://localhost:3000/user/home&lt;/code&gt; (should get redirected to the below URL)
go to: &lt;code&gt;http://localhost:3000/user/logins&lt;/code&gt;
enter the &amp;ldquo;
&lt;a href=&#34;mailto:tester@test.ch&#34;&gt;tester@test.ch&lt;/a&gt;&amp;rdquo; email
Check mailhog for the link &lt;code&gt;http://localhost:8025/&lt;/code&gt;
Click the link you should now be on &lt;code&gt;http://localhost:3000/user/home&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Assuming everything works:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;working magic links using Rails Global ID&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; obviously automated tests are important (both spec and feature tests).&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Rails GlobalID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The nice thing about these is that the auto expire - simplifying the code a lot.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/rails/globalid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/rails/globalid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.magicalruby.com/implementing-magic-links-in-rails/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.magicalruby.com/implementing-magic-links-in-rails/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Token using SecureRandom&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With these you need to create your own expiration and lookup system (more code add a migration), but will work with any framework.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(using uuids) - 
&lt;a href=&#34;https://oozou.com/blog/how-to-implement-passwordless-authentication-in-ruby-on-rails-154&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://oozou.com/blog/how-to-implement-passwordless-authentication-in-ruby-on-rails-154&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(using SecureRandom) - 
&lt;a href=&#34;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Devise Options&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Devise Plugin - 
&lt;a href=&#34;https://github.com/abevoelker/devise-passwordless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/abevoelker/devise-passwordless&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do it Yourself Devise - 
&lt;a href=&#34;https://dev.to/matiascarpintini/magic-links-with-ruby-on-rails-and-devise-4e3o&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/matiascarpintini/magic-links-with-ruby-on-rails-and-devise-4e3o&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do it yourself Devise - 
&lt;a href=&#34;https://www.mintbit.com/blog/passwordless-authentication-in-ruby-on-rails-with-devise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.mintbit.com/blog/passwordless-authentication-in-ruby-on-rails-with-devise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Other Options&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;passwordless gem - 
&lt;a href=&#34;https://github.com/mikker/passwordless#token-and-session-expiry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/mikker/passwordless#token-and-session-expiry&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;magic-link gem - 
&lt;a href=&#34;https://github.com/dvanderbeek/magic-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/dvanderbeek/magic-link&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using Sorcery - 
&lt;a href=&#34;https://fullstackheroes.com/rails/sorcery-passwordless-authentication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fullstackheroes.com/rails/sorcery-passwordless-authentication/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using Sourcery - 
&lt;a href=&#34;https://www.sitepoint.com/magical-authentication-sorcery/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.sitepoint.com/magical-authentication-sorcery/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(using JWTs) - 
&lt;a href=&#34;https://blog.kiprosh.com/implement-passwordless-authentication-via-magic-link-in-rails-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.kiprosh.com/implement-passwordless-authentication-via-magic-link-in-rails-api/&lt;/a&gt;
&lt;strong&gt;Passwordless Security Overview&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Sessions&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://blog.saeloun.com/2019/09/12/rails-6-adds-dig-to-actiondispatch-request-session.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.saeloun.com/2019/09/12/rails-6-adds-dig-to-actiondispatch-request-session.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Phoenix 1.5 authentication with POW</title>
      <link>https://btihen.me/post_elixir_phoenix/phoenix_1_5_authentication_pow/</link>
      <pubDate>Sun, 25 Apr 2021 01:01:53 +0200</pubDate>
      <guid>https://btihen.me/post_elixir_phoenix/phoenix_1_5_authentication_pow/</guid>
      <description>&lt;h2 id=&#34;auth&#34;&gt;Auth&lt;/h2&gt;
&lt;p&gt;Auth with POW&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.skcript.com/svr/using-bamboo-to-send-emails-in-phoenix/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.skcript.com/svr/using-bamboo-to-send-emails-in-phoenix/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.kabisa.nl/tech/real-world-phoenix-lets-auth-some-users/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.kabisa.nl/tech/real-world-phoenix-lets-auth-some-users/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.kabisa.nl/tech/real-world-phoenix-sign-up-flow-spa-style-with-liveview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.kabisa.nl/tech/real-world-phoenix-sign-up-flow-spa-style-with-liveview/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://medium.com/@andreichernykh/phoenix-simple-authentication-authorization-in-step-by-step-tutorial-form-dc93ea350153&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://medium.com/@andreichernykh/phoenix-simple-authentication-authorization-in-step-by-step-tutorial-form-dc93ea350153&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;POW and LiveViews&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://dev.to/oliverandrich/how-to-connect-pow-and-live-view-in-your-phoenix-project-1ga1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/oliverandrich/how-to-connect-pow-and-live-view-in-your-phoenix-project-1ga1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Auth with auth.gen&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://elixircasts.io/using-phx_gen_auth-for-phoenix-authentication&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://elixircasts.io/using-phx_gen_auth-for-phoenix-authentication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-phx-gen-auth-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-phx-gen-auth-part-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-phx-gen-auth-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-phx-gen-auth-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://fullstackphoenix.com/tutorials/combining-authentication-solutions-with-guardian-and-phx-gen-auth&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fullstackphoenix.com/tutorials/combining-authentication-solutions-with-guardian-and-phx-gen-auth&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Auth with PubSub&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://curiosum.dev/blog/elixir-phoenix-liveview-messenger-part-3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://curiosum.dev/blog/elixir-phoenix-liveview-messenger-part-3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Auth with Email&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://hex.pm/packages/bamboo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hex.pm/packages/bamboo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://hexdocs.pm/bamboo_smtp/readme.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hexdocs.pm/bamboo_smtp/readme.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://elixircasts.io/sending-email-with-bamboo-part-1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://elixircasts.io/sending-email-with-bamboo-part-1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://elixircasts.io/sending-email-with-bamboo-part-2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://elixircasts.io/sending-email-with-bamboo-part-2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://devato.com/post/use-bamboo-to-send-email-in-phoenix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://devato.com/post/use-bamboo-to-send-email-in-phoenix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.kabisa.nl/tech/real-world-phoenix-lets-send-some-emails/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.kabisa.nl/tech/real-world-phoenix-lets-send-some-emails/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;General Auth Principles

&lt;a href=&#34;https://nithinbekal.com/posts/phoenix-authentication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://nithinbekal.com/posts/phoenix-authentication/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mail-in-test-env&#34;&gt;Mail in Test Env&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/mailhog/MailHog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/mailhog/MailHog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://mailcatcher.me/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mailcatcher.me/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Pow has the advantage that it updates security patches &amp;ndash; since its a well maintained library.&lt;/p&gt;
&lt;p&gt;This repo can be found at: 
&lt;a href=&#34;https://github.com/btihen/phoenix_1_5_pow_auth_config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/btihen/phoenix_1_5_pow_auth_config&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Get the latest version from: 
&lt;a href=&#34;https://hex.pm/packages/pow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hex.pm/packages/pow&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;{:pow, &amp;quot;~&amp;gt; 1.0&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install the dependency:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix deps.get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install POW:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix pow.install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets verify all is good with the install:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix deps.compile
mix help | grep pow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now hopefully you see some new &lt;code&gt;pow&lt;/code&gt; commands&lt;/p&gt;
&lt;h2 id=&#34;configure-pow&#34;&gt;Configure Pow&lt;/h2&gt;
&lt;p&gt;There are three files you&amp;rsquo;ll need to configure first before you can use Pow.&lt;/p&gt;
&lt;p&gt;First, append this to &lt;code&gt;config/config.exs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :fare, :pow,
  user: Fare.Users.User,
  repo: Fare.Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, add &lt;code&gt;Pow.Plug.Session&lt;/code&gt; plug to &lt;code&gt;lib/fare_web/endpoint.ex&lt;/code&gt; after &lt;code&gt;plug Plug.Session&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule FareWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :fare   # add this line HERE!

  # ...

  plug Plug.Session, @session_options
  plug Pow.Plug.Session, otp_app: :fare  # add this line HERE!
  plug FareWeb.Router
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Last, update &lt;code&gt;lib/fare_web/router.ex&lt;/code&gt; with the Pow routes - this first time we need to do a little extra config:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;  pipeline :api do
    plug :accepts, [&amp;quot;json&amp;quot;]
  end
  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through [:browser, :protected]

    # Add your protected routes here
  end

  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through :browser

    live &amp;quot;/&amp;quot;, PageLive, :index
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Should now look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;  pipeline :api do
    plug :accepts, [&amp;quot;json&amp;quot;]
  end

  pipeline :protected do
    plug Pow.Plug.RequiredAuthentication,
          error_handler: Pow.Phoenix.PlugErrorHandler
  end

  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
  end

  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through [:browser, :protected]

    # Add your protected routes here
    resources &amp;quot;/tasks&amp;quot;, TaskController
  end

  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through :browser

    live &amp;quot;/&amp;quot;, PageLive, :index
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets check the routes - that all is well configured:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix phx.routes | grep pow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hopefully you see some new pow routes.&lt;/p&gt;
&lt;p&gt;Now we can migrate to create our users table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we start phoenix:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix phx.server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and open phoenix: &lt;code&gt;localhost:4000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;pow-user-links&#34;&gt;POW user Links&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Notice there is no menu option to login - lets build a simple signup/signin/logout link.&lt;/p&gt;
&lt;p&gt;In root.html.eex find &lt;code&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;https://hexdocs.pm/phoenix/overview.html&amp;quot;&amp;gt;Get Started&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/code&gt; and we will replace it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;            &amp;lt;%= if Pow.Plug.current_user(@conn) do %&amp;gt;
              &amp;lt;li&amp;gt;
                &amp;lt;%= link &amp;quot;#{@current_user.email}&amp;quot;, to: Routes.pow_registration_path(@conn, :edit) %&amp;gt;
              &amp;lt;/li&amp;gt;
              &amp;lt;li&amp;gt;
                &amp;lt;%= link &amp;quot;Sign-out&amp;quot;, to: Routes.pow_session_path(@conn, :delete), method: :delete %&amp;gt;
              &amp;lt;/li&amp;gt;
            &amp;lt;% else %&amp;gt;
              &amp;lt;li&amp;gt;&amp;lt;%= link &amp;quot;Sign-in&amp;quot;, to: Routes.pow_session_path(@conn, :new) %&amp;gt;&amp;lt;/li&amp;gt;
              &amp;lt;li&amp;gt;&amp;lt;%= link &amp;quot;Register&amp;quot;, to: Routes.pow_registration_path(@conn, :new) %&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now reload and try it out:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;you should be able to register&lt;/li&gt;
&lt;li&gt;sign-out&lt;/li&gt;
&lt;li&gt;sign in&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;customizable-login-pages&#34;&gt;Customizable Login pages&lt;/h2&gt;
&lt;p&gt;Generate the pages to customize with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix pow.phoenix.gen.templates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now be sure to change the config in &lt;code&gt;config/confix.ex&lt;/code&gt; from:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: Fare.Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without updating the config the newly generated pages won&amp;rsquo;t be used!&lt;/p&gt;
&lt;p&gt;The new templates to modify are found in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib/fare_web/templates/pow/registration&lt;/code&gt; &amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/fare_web/templates/pow/session&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now make a small change to the pages to ensure all works.&lt;/p&gt;
&lt;h2 id=&#34;create-a-restricted-user-page&#34;&gt;Create a restricted user page&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;

&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Create a normal html page first:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix phx.gen.html Tasks Task tasks description:string completed:boolean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BE SURE TO PUT the new route in the &lt;code&gt;protected&lt;/code&gt; area of the routes file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# lib/fare_web/router.ex
  scope &amp;quot;/&amp;quot;, MyAppWeb do
    pipe_through [:browser, :protected]

    # Add your protected routes here
    resources &amp;quot;/tasks&amp;quot;, TaskController
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now of course run the migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now &lt;code&gt;/tasks&lt;/code&gt; should only be availble to signed in users.  Be sure you are logged out and cannot get to the &lt;code&gt;/tasks&lt;/code&gt; route (and infact are redirected to sign-in). And once logged in the page works as expected.&lt;/p&gt;
&lt;h2 id=&#34;extensions&#34;&gt;Extensions&lt;/h2&gt;
&lt;h3 id=&#34;persistent-login-sessions-remember-me&#34;&gt;Persistent Login Sessions (Remember me)&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Currently every time the user closes the browser they are logged out - the login cookie doesn&amp;rsquo;t persist - most users would like the option to change this - with a &lt;code&gt;remember me&lt;/code&gt; option.&lt;/p&gt;
&lt;p&gt;in &lt;code&gt;config/config.exs&lt;/code&gt; change the &lt;code&gt;:pow&lt;/code&gt; config to look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  # add the following two lines
  extensions: [PowPersistentSession],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in &lt;code&gt;/lib/my_app_web/endpoint.ex&lt;/code&gt; we need to add the persistent cookie setting immediately after the &lt;code&gt;Pow.Plug.Session&lt;/code&gt; plug and before the routing &lt;code&gt;MyAppWeb.Router&lt;/code&gt; plug &amp;ndash; now the end of the endpoint file should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;  # enable Pow session based authentication
  plug Pow.Plug.Session, otp_app: :warehouse
  # enable Pow persistent sessions
  plug PowPersistentSession.Plug.Cookie
  # routing plug
  plug MyAppWeb.Router
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;just above the login button on the &lt;code&gt;sign-in&lt;/code&gt; page add the following check-box:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# lib/fare_web/templates/pow/session/new.html.eex
  &amp;lt;%= label f, :persistent_session, &amp;quot;Remember me&amp;quot; %&amp;gt;
  &amp;lt;%= checkbox f, :persistent_session %&amp;gt;

  &amp;lt;div&amp;gt;
    &amp;lt;%= submit &amp;quot;Sign in&amp;quot; %&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;restart Phoenix with: &lt;code&gt;mix phx.server&lt;/code&gt; and now you should be able to close your browser and re-open the link and stay logged in if the &lt;code&gt;remember-me&lt;/code&gt; is clicked.&lt;/p&gt;
&lt;h2 id=&#34;after-logout---go-to-landing-page-after-hook-routing&#34;&gt;After Logout - go to Landing Page (After Hook Routing)&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One little annoying thing is that when we logout we go to the sign-in page instead of the landing page.  We can fix that by adding a call_back_route - you can find all the callback routes at: 
&lt;a href=&#34;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&lt;/a&gt; - we will use: the &lt;code&gt;after_sign_out_path&lt;/code&gt; callback.&lt;/p&gt;
&lt;p&gt;To do this we will make a new &lt;code&gt;pow.routes&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch lib/warehouse_web/pow/routes.ex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;cat &amp;lt;&amp;lt; EOF&amp;gt; lib/my_app_web/pow/routes.ex
defmodule MyAppWeb.Pow.Routes do
  use Pow.Phoenix.Routes
  alias MyAppWeb.Router.Helpers, as: Routes

  def after_sign_out_path(conn), do: Routes.page_path(conn, :index)
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now finally update &lt;code&gt;config/confix.exs&lt;/code&gt; by adding &lt;code&gt;routes_backend: MyAppWeb.Pow.Routes&lt;/code&gt; to the &lt;code&gt;:pow&lt;/code&gt; config so now it would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  extensions: [PowPersistentSession],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks,
  routes_backend: MyAppWeb.Pow.Routes    # add this line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming all works we will snapshot now!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;on logout go to landing page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;password-reset-and-email-confirmation&#34;&gt;Password Reset and Email Confirmation&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/pow-auth/pow_assent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/pow-auth/pow_assent&lt;/a&gt;

&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;

&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The following are the possible extensions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PowResetPassword&lt;/li&gt;
&lt;li&gt;PowEmailConfirmation&lt;/li&gt;
&lt;li&gt;PowPersistentSession&lt;/li&gt;
&lt;li&gt;PowInvitation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s start with password reset and email confirmation.&lt;/p&gt;
&lt;p&gt;First we need to do a migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix pow.extension.ecto.gen.migrations --extension PowResetPassword --extension PowEmailConfirmation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now update the phoenix config &lt;code&gt;config/config.ex&lt;/code&gt; again from:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now update the &lt;code&gt;LIB_PATH/users/user.ex&lt;/code&gt; file from:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Fare.Users.User do
  use Ecto.Schema
  use Pow.Ecto.Schema

  schema &amp;quot;users&amp;quot; do
    pow_user_fields()

    timestamps()
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule MyApp.Users.User do
  use Ecto.Schema
  use Pow.Ecto.Schema
  use Pow.Extension.Ecto.Schema,
      extensions: [PowResetPassword, PowEmailConfirmation]

  schema &amp;quot;users&amp;quot; do
    pow_user_fields()

    timestamps()
  end

  def changeset(user_or_changeset, attrs) do
    user_or_changeset
    |&amp;gt; pow_changeset(attrs)
    |&amp;gt; pow_extension_changeset(attrs)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course the routes &lt;code&gt;WEB_PATH/router.ex&lt;/code&gt; too - at the top of the file add:
so it looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule MyAppWeb.Router do
  use MyAppWeb, :router
  use Pow.Phoenix.Router
  use Pow.Extension.Phoenix.Router,
      extensions: [PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in the pow routes config change from:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
    pow_extension_routes()
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now finally, we need can update any views needed by POW&amp;rsquo;s new extensions with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mix pow.extension.phoenix.gen.templates --extension PowResetPassword --extension PowEmailConfirmation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can update the sign-in page with a reset password button.  We will add the following, to the end of &lt;code&gt;lib/fare_web/templates/pow/session/new.html.eex&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;|
&amp;lt;span&amp;gt;
&amp;lt;%= link &amp;quot;Reset Password&amp;quot;, to: Routes.pow_reset_password_reset_password_path(@conn, :new) %&amp;gt;
&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets be sure we can link to reset password view.&lt;/p&gt;
&lt;p&gt;First we will do our migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now to to sign-in and see if the reset password link works.
Cool it does, but it we try to use it - it complains it needs email back-end setup.&lt;/p&gt;
&lt;h2 id=&#34;email-backend&#34;&gt;Email backend&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First we will create a mailer function in: &lt;code&gt;lib/my_app_web/pow/pow_mailer.ex&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;mkdir lib/my_app_web/pow/
touch lib/my_app_web/pow/pow_mailer.ex
cat &amp;lt;&amp;lt;EOF &amp;gt; lib/my_app_web/pow/pow_mailer.ex
defmodule FareWeb.Pow.Mailer do
  use Pow.Phoenix.Mailer

  require Logger

  @impl true
  def cast(%{user: user, subject: subject, text: text, html: html}) do
    # Forward Struct to logger - disable/remove when Bamboo configured
    %{to: user.email, subject: subject, text: text, html: html}
  end

  @impl true
  def process(email) do
    # log email sent
    Logger.debug(&amp;quot;E-mail sent: #{inspect email}&amp;quot;)
  end
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now that we have an email template we need to tell pow about the mailer with the config: &lt;code&gt;mailer_backend: MyAppWeb.Pow.Mailer&lt;/code&gt; in &lt;code&gt;config/config.exs&lt;/code&gt; so change to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# config for pow - user authentication
config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  mailer_backend: MyAppWeb.Pow.Mailer,  # add this
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now generate the POW mail templates - with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix pow.extension.phoenix.mailer.gen.templates --extension PowResetPassword --extension PowEmailConfirmation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Phoenix also needs to know about the mailer templates we will generate so add to &lt;code&gt;lib/my_app_web.ex&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;  def mailer_view do
    quote do
      use Phoenix.View, root: &amp;quot;lib/my_app_web/templates&amp;quot;,
                        namespace: MyAppWeb

      use Phoenix.HTML
    end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the final config change in &lt;code&gt;config/config.ex&lt;/code&gt; to access our new templates:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# config for pow - user authentication
config :fare, :pow,
  user: Fare.Users.User,
  repo: Fare.Repo,
  web_module: MyAppWeb,
  web_mailer_module: MyAppWeb,          # add this to access the templates
  mailer_backend: MyAppWeb.Pow.Mailer,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation],
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we resart phoenix and test out reset link - we should see in the logs &amp;lsquo;a pretend sent email&amp;rsquo; - something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[debug] E-mail sent: %{html: &amp;quot;&amp;lt;h3&amp;gt;Hi,&amp;lt;/h3&amp;gt;\n&amp;lt;p&amp;gt;Please use the following link to reset your password:&amp;lt;/p&amp;gt;\n&amp;lt;p&amp;gt;&amp;lt;a href=\&amp;quot;http://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw\&amp;quot;&amp;gt;http://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;\n&amp;lt;p&amp;gt;You can disregard this email if you didn&amp;amp;#39;t request a password reset.&amp;lt;/p&amp;gt;&amp;quot;, subject: &amp;quot;Reset password link&amp;quot;, text: &amp;quot;Hi,\n\nPlease use the following link to reset your password:\n\nhttp://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw\n\nYou can disregard this email if you didn&#39;t request a password reset.\n&amp;quot;, to: &amp;quot;btihen@gmail.com&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;copy the link out of the email in the log:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:4000/reset-password/SFMyNTY.MTJkNDliZWItZTg2My00ZDM3LTg2YzgtYzE5MDdjMDk5ODgz.kFRCfvdOSeEnupbbujdAKoaCuMXXk91qzZCUMrB43mw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;into the browser - type a new password and try to login.&lt;/p&gt;
&lt;p&gt;Assuming all works we will snapshot now!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;pow configured to send emails - no sender yet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;after-logout---go-to-landing-page-after-hook-routing-1&#34;&gt;After Logout - go to Landing Page (After Hook Routing)&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One little annoying thing is that when we logout we go to the sign-in page instead of the landing page.  We can fix that by adding a call_back_route - you can find all the callback routes at: 
&lt;a href=&#34;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/routes.ex&lt;/a&gt; - we will use: the &lt;code&gt;after_sign_out_path&lt;/code&gt; callback.&lt;/p&gt;
&lt;p&gt;To do this we will make a new &lt;code&gt;pow.routes&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch lib/warehouse_web/pow/routes.ex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;cat &amp;lt;&amp;lt; EOF&amp;gt; lib/my_app_web/pow/routes.ex
defmodule MyAppWeb.Pow.Routes do
  use Pow.Phoenix.Routes
  alias MyAppWeb.Router.Helpers, as: Routes

  def after_sign_out_path(conn), do: Routes.page_path(conn, :index)
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now finally update &lt;code&gt;config/confix.exs&lt;/code&gt; by adding &lt;code&gt;routes_backend: MyAppWeb.Pow.Routes&lt;/code&gt; to the &lt;code&gt;:pow&lt;/code&gt; config so now it would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :my_app, :pow,
  user: MyApp.Users.User,
  repo: MyApp.Repo,
  web_module: MyAppWeb,
  web_mailer_module: MyAppWeb,
  mailer_backend: MyAppWeb.Pow.Mailer,
  routes_backend: MyAppWeb.Pow.Routes,  # Add this line
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming all works we will snapshot now!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;on logout go to landing page&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;configure-email-bamboo-with-pow&#34;&gt;Configure Email BAMBOO with POW&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://hexdocs.pm/bamboo/readme.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hexdocs.pm/bamboo/readme.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.kabisa.nl/tech/real-world-phoenix-lets-send-some-emails/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.kabisa.nl/tech/real-world-phoenix-lets-send-some-emails/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Use Bamboo to do the mailing find the new versions at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://hex.pm/packages/bamboo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hex.pm/packages/bamboo&lt;/a&gt;
Add to &lt;code&gt;mix.exs&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;    {:bamboo, &amp;quot;~&amp;gt; 2.1&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get the new dependency:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix deps.get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the Test Config we need to configure bamboo with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# config/test.exs
config :my_app, MyApp.Mailer,
  adapter: Bamboo.TestAdapter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the Dev Config lets setup the in-memory email config&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# config/dev.exs
config :fare, FareWeb.Pow.Mailer,
  adapter: Bamboo.LocalAdapter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When using &lt;code&gt;Bamboo.LocalAdapter&lt;/code&gt; in dev mode we can view the email (without digging through the log file) using &lt;code&gt;Bamboo.EmailPreviewPlug&lt;/code&gt; - we set this up with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;if Mix.env == :dev do
  forward &amp;quot;/sent_emails&amp;quot;, Bamboo.EmailPreviewPlug
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let&amp;rsquo;s setup our mailer to use Bamboo - we will edit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# lib/my_app_web/pow/pow_mailer.ex
defmodule MyAppWeb.Pow.Mailer do
  use Pow.Phoenix.Mailer

  # ADDED to use Bamboo
  use Bamboo.Mailer, otp_app: :fare  # Bamboo needs to know the supervisor
  import Bamboo.Email                # provides access to the Bamboo&#39;s methods

  require Logger

  @impl true
  def cast(%{user: user, subject: subject, text: text, html: html}) do
    # ADDED when Bamboo is configured
    new_email(
      to: user.email,
      from: &amp;quot;reading-list@example.com&amp;quot;,
      subject: subject,
      html_body: html,
      text_body: text
    )
  end

  @impl true
  def process(email) do
    # ADDED when Bamboo is configured
    deliver_now(email)

    # check email functionality and contents
    Logger.debug(&amp;quot;E-mail sent: #{inspect email}&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s register a new account (or reset a password).
Now we can see the sent email at: http://localhost/sent_emails (in dev mode)&lt;/p&gt;
&lt;h2 id=&#34;bamboo-adapters---smtp-config-production-ideas&#34;&gt;Bamboo Adapters - SMTP Config (Production Ideas)&lt;/h2&gt;
&lt;p&gt;Available adapters are listed at: 
&lt;a href=&#34;https://hexdocs.pm/bamboo/readme.html#available-adapters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hexdocs.pm/bamboo/readme.html#available-adapters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given the number of adapters - here we will configure just SMTP (and learn to trap it while testing)&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.kabisa.nl/tech/real-world-phoenix-lets-send-some-emails/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.kabisa.nl/tech/real-world-phoenix-lets-send-some-emails/&lt;/a&gt;

&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Use Bamboo to do the mailing find the new versions at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://hex.pm/packages/bamboo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hex.pm/packages/bamboo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://hex.pm/packages/bamboo_smtp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hex.pm/packages/bamboo_smtp&lt;/a&gt;
Add to &lt;code&gt;mix.exs&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;    {:bamboo, &amp;quot;~&amp;gt; 2.1&amp;quot;},
    {:bamboo_smtp, &amp;quot;~&amp;gt; 2.1&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now install and setup up: 
&lt;a href=&#34;https://github.com/mailhog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/mailhog/&lt;/a&gt; (on a MacOS) simply install with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and run mailhog with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or if you want mailhog running all the time in the background you can type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  brew services start mailhog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or you can use: or 
&lt;a href=&#34;https://mailcatcher.me/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mailcatcher.me/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;These serivices  - listen on &lt;code&gt;localhost:1025&lt;/code&gt; and you can view the email at: http://localhost:8025&lt;/p&gt;
&lt;p&gt;now configure the mail service (in &lt;code&gt;config/dev.exs&lt;/code&gt;) to use Mailhog or Mailcather with Phoenix by adding:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# config/dev.exs
config :my_app, MyAppWeb.Pow.Mailer,
  adapter: Bamboo.SMTPAdapter,
  server: &amp;quot;localhost&amp;quot;,
  port: 1025
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In production it might look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# config/config.exs
config :my_app, MyApp.Mailer,
  adapter: Bamboo.SMTPAdapter,
  server: &amp;quot;smtp.domain&amp;quot;,
  hostname: &amp;quot;your.domain&amp;quot;,
  port: 1025,
  username: &amp;quot;your.name@your.domain&amp;quot;, # or {:system, &amp;quot;SMTP_USERNAME&amp;quot;}
  password: &amp;quot;pa55word&amp;quot;, # or {:system, &amp;quot;SMTP_PASSWORD&amp;quot;}
  tls: :if_available, # can be `:always` or `:never`
  allowed_tls_versions: [:&amp;quot;tlsv1&amp;quot;, :&amp;quot;tlsv1.1&amp;quot;, :&amp;quot;tlsv1.2&amp;quot;], # or {:system, &amp;quot;ALLOWED_TLS_VERSIONS&amp;quot;} w/ comma seprated values (e.g. &amp;quot;tlsv1.1,tlsv1.2&amp;quot;)
  ssl: false, # can be `true`
  retries: 1,
  no_mx_lookups: false, # can be `true`
  auth: :if_available # can be `:always`. If your smtp relay requires authentication set it to `:always`.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you will need to start your mail-trap (in a separate cli terminal):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mailhog
# or `mailcather`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when you register a new account or change a password you can see the email at:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http://localhost:8025
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;customizing---pow-flash-messages&#34;&gt;Customizing - POW Flash messages&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Create a new module for our messages.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;touch lib/my_app_web/pow/messages.ex
cat &amp;lt;&amp;lt;EOF&amp;gt;&amp;gt;lib/my_app_web/pow/messages.ex
defmodule MyAppWeb.Pow.Messages do
  use Pow.Phoenix.Messages
  use Pow.Extension.Phoenix.Messages,  # add extensions in use
    extensions: [PowResetPassword, PowEmailConfirmation]

  import MyAppWeb.Gettext

  # PowMessages - functions defined:
  # https://hexdocs.pm/pow/Pow.Phoenix.Messages.html#summary
  # https://github.com/danschultzer/pow/blob/master/lib/pow/phoenix/messages.ex
  def signed_in(_conn), do: gettext(&amp;quot;Welcome back.&amp;quot;)
  def signed_out(_conn), do: gettext(&amp;quot;Signed out successfullly.&amp;quot;)
  def user_not_authenticated(_conn), do: gettext(&amp;quot;You need to sign in to see this page.&amp;quot;)

  # PowResetPassword - functions defined:
  # https://github.com/danschultzer/pow/blob/master/lib/extensions/reset_password/phoenix/messages.ex
  def invalid_token(_conn), do: &amp;quot;The reset token has expired.&amp;quot;
  def password_has_been_reset(_conn), do: &amp;quot;The password has been updated.&amp;quot;
  def email_has_been_sent(_conn), do: &amp;quot;An email with reset instructions has been sent to you.&amp;quot;

  # PowEmailConfirmation - functions defined:
  # https://github.com/danschultzer/pow/blob/master/lib/extensions/email_confirmation/phoenix/messages.ex
  def email_has_been_confirmed(_conn), do: &amp;quot;The email address has been confirmed.&amp;quot;
  def email_confirmation_failed(_conn), do: &amp;quot;The email address couldn&#39;t be confirmed.&amp;quot;
  def email_confirmation_required(_conn), do: &amp;quot;You need to confirm your e-mail with the link e-mailed to you.&amp;quot;
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To be able to use this module we need to tell our config about it - so we update &lt;code&gt;config/config.exs&lt;/code&gt; with &lt;code&gt;messages_backend: FareWeb.Pow.Messages&lt;/code&gt; - so now it looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :fare, :pow,
  user: Fare.Users.User,
  repo: Fare.Repo,
  web_module: FareWeb,
  web_mailer_module: FareWeb,
  mailer_backend: Fare.Pow.Mailer,
  routes_backend: FareWeb.Pow.Routes,
  messages_backend: FareWeb.Pow.Messages,  # Add this line
  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks,
  extensions: [PowPersistentSession, PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you should see your custom messages!&lt;/p&gt;
&lt;p&gt;let&amp;rsquo;s snapshot this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;allow POW to send custom / i18n messages&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;configure-to-allow-3rd-parties---google-apple-github-etc&#34;&gt;Configure to allow 3rd Parties - Google, Apple, Github, etc.&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/pow-auth/pow_assent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/pow-auth/pow_assent&lt;/a&gt;

&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First add to the mix file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;    # third party auth
    {:pow_assent, &amp;quot;~&amp;gt; 0.4.10&amp;quot;},
    # recommended for SSL validation with :httpc adapter
    {:certifi, &amp;quot;~&amp;gt; 2.4&amp;quot;},
    {:ssl_verify_fun, &amp;quot;~&amp;gt; 1.1&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and of course: &lt;code&gt;mix deps.get&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and install with: &lt;code&gt;mix pow_assent.install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and now configure &lt;code&gt;lib/fare/users/user.ex&lt;/code&gt; after &lt;code&gt;use Pow.Ecto.Schema&lt;/code&gt; add &lt;code&gt;use PowAssent.Ecto.Schema&lt;/code&gt; so now the top of this file should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# lib/fare/users/user.ex
defmodule Fare.Users.User do
  use Ecto.Schema
  use Pow.Ecto.Schema
  use PowAssent.Ecto.Schema  # added in this step
  use Pow.Extension.Ecto.Schema,
      extensions: [PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At the top of the &lt;code&gt;lib/fare_web/router.ex&lt;/code&gt; file after &lt;code&gt;use PowAssent.Phoenix.Router&lt;/code&gt; add &lt;code&gt;use PowAssent.Phoenix.Router&lt;/code&gt; - now the top of this file should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# lib/fare_web/router.ex
defmodule MyAppWeb.Router do
  use MyAppWeb, :router
  use Pow.Phoenix.Router
  use PowAssent.Phoenix.Router
  use Pow.Extension.Phoenix.Router,
      extensions: [PowResetPassword, PowEmailConfirmation]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now after the last pipelines add a new &lt;code&gt;pipeline&lt;/code&gt; and its &lt;code&gt;scope&lt;/code&gt; - its a copy of the &lt;code&gt;:browser&lt;/code&gt; pipeline - without &lt;code&gt;:protect_from_forgery&lt;/code&gt; since that conflicts with &lt;strong&gt;OAuth&lt;/strong&gt; &amp;amp; after &lt;code&gt;pow_routes()&lt;/code&gt; add &lt;code&gt;pow_assent_routes()&lt;/code&gt; so now this section of the routes looks like (when Phoenix is configured for LiveView):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;  pipeline :skip_csrf_protection do
    plug :accepts, [&amp;quot;html&amp;quot;]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, {FareWeb.LayoutView, :root}
    # plug :protect_from_forgery     # conflicts with oauth
    plug :put_secure_browser_headers
  end

  scope &amp;quot;/&amp;quot; do
    pipe_through :skip_csrf_protection

    # this adds new pow routes
    pow_assent_authorization_post_callback_routes()
  end

  scope &amp;quot;/&amp;quot; do
    pipe_through :browser

    pow_routes()
    pow_assent_routes()    # newly added
    pow_extension_routes()
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember to run the new migrations with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix ecto.migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generate the PowAssent template too (the page when using this where the user add username and OAuth password from remote site):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mix pow_assent.phoenix.gen.templates
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;setup-remote-oauth-providers-github---for-now&#34;&gt;Setup remote OAuth providers (Github - for now)&lt;/h3&gt;
&lt;p&gt;Go to:

&lt;a href=&#34;https://github.com/settings/applications/new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/settings/applications/new&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enter an &lt;strong&gt;Application name&lt;/strong&gt; and enter the &lt;strong&gt;Homepage url&lt;/strong&gt; as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http://localhost:4000/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the &lt;strong&gt;Authorization callback&lt;/strong&gt; (for our dev environment) as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http://localhost:4000/auth/github/callback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Configure Github Credential Secrets&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://hexdocs.pm/elixir/Application.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hexdocs.pm/elixir/Application.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://devato.com/post/handling-environment-variables-in-phoenix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://devato.com/post/handling-environment-variables-in-phoenix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/44510403/phoenix-import-module-into-config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://stackoverflow.com/questions/44510403/phoenix-import-module-into-config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/30995743/how-to-get-a-variable-value-from-environment-files-in-phoenix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://stackoverflow.com/questions/30995743/how-to-get-a-variable-value-from-environment-files-in-phoenix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First update &lt;code&gt;.gitignore&lt;/code&gt; with the line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;**/*.secret.exs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then add in our case the &lt;code&gt;dev.secrets.exs&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch config/dev.secret.exs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you get your &lt;strong&gt;Client ID&lt;/strong&gt; and &lt;strong&gt;Client secrets&lt;/strong&gt; you can configure  &lt;code&gt;config/dev.secret.exs&lt;/code&gt; with the following config:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;import Config

config :my_app, :pow_assent,
  providers: [
    github: [
      client_id: &amp;quot;REPLACE_WITH_CLIENT_ID&amp;quot;,
      client_secret: &amp;quot;REPLACE_WITH_CLIENT_SECRET&amp;quot;,
      strategy: Assent.Strategy.Github
    ]
  ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now at the END of &lt;code&gt;config/dev.exs&lt;/code&gt; add the line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;import_config &amp;quot;dev.secret.exs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now at the end of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib/my_app_web/templates/pow/registration/edit.html.eex&lt;/code&gt; (edit profile),&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/my_app_web/templates/pow/registration/new.html.eex&lt;/code&gt; (register),&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/fare_web/templates/pow/session/new.html.eex&lt;/code&gt; (sign-in)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add the following comprehension to list all the configured OAuth log-in links:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;&amp;lt;%=
  for link &amp;lt;- PowAssent.Phoenix.ViewHelpers.provider_links(@conn),
      do: content_tag(:span, link)
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pow readme: 
&lt;a href=&#34;https://hexdocs.pm/pow/README.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hexdocs.pm/pow/README.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;video tutorial: 
&lt;a href=&#34;https://www.youtube.com/watch?v=hnD0Z0LGMIk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=hnD0Z0LGMIk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;add pubsub 
&lt;a href=&#34;https://curiosum.dev/blog/elixir-phoenix-liveview-messenger-part-3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://curiosum.dev/blog/elixir-phoenix-liveview-messenger-part-3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;add email to pow: 
&lt;a href=&#34;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/oliverandrich/learn-elixir-and-phoenix-add-authentication-55kl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://experimentingwithcode.com/phoenix-authentication-with-pow-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rails Devise User Model with Roles</title>
      <link>https://btihen.me/post_ruby_rails/rails_devise_users_namespaced/</link>
      <pubDate>Fri, 10 Jul 2020 20:45:51 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/rails_devise_users_namespaced/</guid>
      <description>&lt;h2 id=&#34;configure-devise-for-multiple-types-of-accounts&#34;&gt;Configure devise (for multiple types of accounts)&lt;/h2&gt;
&lt;p&gt;install the devise engine:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails generate devise:install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now follow the basic setup config &amp;ndash; add to &lt;code&gt;config/environments/development.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.action_mailer.default_url_options = { host: &#39;localhost&#39;, port: 3000 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add notifications to the layout for devise in &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; just above &lt;code&gt;&amp;lt;%= yeild %&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;lt;p class=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;alert&amp;quot;&amp;gt;&amp;lt;%= alert %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now create one or more models for devise:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails g devise:views
rails generate devise user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update the routes to put the login in separate routes in &lt;code&gt;config/routes.rb&lt;/code&gt; - make the routes look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  devise_for :users,  path: &#39;users&#39;  # http://localhost:3000/users/sign_in
  devise_for :admins, path: &#39;admins&#39; # http://localhost:3000/admins/sign_in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;turn on scoped views (since login forms can be different) in &lt;code&gt;config/initializers/devise.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.scoped_views = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create the scoped views: (instead of: rails g devise:views) do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails g devise:views users/devise
rails g devise:views admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we should open these migrations and uncomment any added fields we use - I generally like to use most of the fields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# frozen_string_literal: true

class DeviseCreateAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    create_table :admins do |t|
      ## Database authenticatable
      t.string :email,              null: false, default: &amp;quot;&amp;quot;
      t.string :encrypted_password, null: false, default: &amp;quot;&amp;quot;

      ## Recoverable
      t.string   :reset_password_token
      t.datetime :reset_password_sent_at

      ## Rememberable
      t.datetime :remember_created_at

      ## Trackable
      t.integer  :sign_in_count, default: 0, null: false
      t.datetime :current_sign_in_at
      t.datetime :last_sign_in_at
      t.inet     :current_sign_in_ip
      t.inet     :last_sign_in_ip

      ## Confirmable
      t.string   :confirmation_token
      t.datetime :confirmed_at
      t.datetime :confirmation_sent_at
      t.string   :unconfirmed_email # Only if using reconfirmable

      ## Lockable
      t.integer  :failed_attempts, default: 0, null: false # Only if lock strategy is :failed_attempts
      t.string   :unlock_token # Only if unlock strategy is :email or :both
      t.datetime :locked_at

      t.timestamps null: false
    end

    add_index :admins, :email,                unique: true
    add_index :admins, :reset_password_token, unique: true
    add_index :admins, :confirmation_token,   unique: true
    add_index :admins, :unlock_token,         unique: true
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and adjust the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;admin&lt;/code&gt; models too and turn on the features we want or need. We will go into detail later, for now I will just add trackable to the models:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable, :trackable,
         :recoverable, :rememberable, :validatable
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and of course migrate too.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create custome controllers for each sessions - this also allows the users to have different fields and features:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails generate devise:controllers users/devise
rails generate devise:controllers admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;configure the routes to point to these new controllers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # http://localhost:3000/users/sign_in
  devise_for :users,  path: &#39;users&#39;,
                      controllers: {
                        sessions:      &#39;users/devise/sessions&#39;,
                        passwords:     &#39;users/devise/passwords&#39;,
                        registrations: &#39;users/devise/registrations&#39;
                      }
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now the routes should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bin/rails routes
                     Prefix Verb   URI Pattern                        Controller#Action
           new_user_session GET    /users/sign_in(.:format)           users/sessions#new
               user_session POST   /users/sign_in(.:format)           users/sessions#create
       destroy_user_session DELETE /users/sign_out(.:format)          users/sessions#destroy
          new_user_password GET    /users/password/new(.:format)      users/passwords#new
         edit_user_password GET    /users/password/edit(.:format)     users/passwords#edit
              user_password PATCH  /users/password(.:format)          users/passwords#update
                            PUT    /users/password(.:format)          users/passwords#update
                            POST   /users/password(.:format)          users/passwords#create
   cancel_user_registration GET    /users/cancel(.:format)            user/registrations#cancel
      new_user_registration GET    /users/sign_up(.:format)           user/registrations#new
     edit_user_registration GET    /users/edit(.:format)              user/registrations#edit
          user_registration PATCH  /users(.:format)                   user/registrations#update
                            PUT    /users(.:format)                   user/registrations#update
                            DELETE /users(.:format)                   user/registrations#destroy
                            POST   /users(.:format)                   user/registrations#create
          new_admin_session GET    /admins/sign_in(.:format)          admin/sessions#new
              admin_session POST   /admins/sign_in(.:format)          admin/sessions#create
      destroy_admin_session DELETE /admins/sign_out(.:format)         admin/sessions#destroy
         new_admin_password GET    /admins/password/new(.:format)     admin/passwords#new
        edit_admin_password GET    /admins/password/edit(.:format)    admin/passwords#edit
             admin_password PATCH  /admins/password(.:format)         admin/passwords#update
                            PUT    /admins/password(.:format)         admin/passwords#update
                            POST   /admins/password(.:format)         admin/passwords#create
  cancel_admin_registration GET    /admins/cancel(.:format)           admin/registrations#cancel
     new_admin_registration GET    /admins/sign_up(.:format)          admin/registrations#new
    edit_admin_registration GET    /admins/edit(.:format)             admin/registrations#edit
         admin_registration PATCH  /admins(.:format)                  admin/registrations#update
                            PUT    /admins(.:format)                  admin/registrations#update
                            DELETE /admins(.:format)                  admin/registrations#destroy
                            POST   /admins(.:format)                  admin/registrations#create
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lets make logged in home pages (for the user and admin)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails g controller users/home index --no-helper --no-assets --no-controller-specs --no-view-specs
rails g controller admins/home index --no-helper --no-assets --no-controller-specs --no-view-specs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now lets update our routes to ponit to these pages if the user is logged in add the following belos the deivse_for commands&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.routes.draw do
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
  # http://localhost:3000/umdzes/sign_in
  devise_for :umdzes, path: &#39;umdzes&#39;,
                      controllers: {
                        sessions:      &#39;umdzes/devise/sessions&#39;,
                        passwords:     &#39;umdzes/devise/passwords&#39;,
                        registrations: &#39;umdzes/devise/registrations&#39;
                      }
  # http://localhost:3000/patrons/sign_in
  devise_for :patrons,  path: &#39;patrons&#39;,
                      controllers: {
                        sessions:      &#39;patrons/devise/sessions&#39;,
                        passwords:     &#39;patrons/devise/passwords&#39;,
                        registrations: &#39;patrons/devise/registrations&#39;
                      }

  authenticated :patron do
    root &#39;patrons/home#index&#39;,     as: :auth_patron_root
  end
  authenticated :umdze do
    root &#39;umdzes/home#index&#39;,      as: :auth_umdze_root
  end
  authenticated :admin do
    root &#39;admins/home#index&#39;, as: :auth_admin_root
  end


  namespace :admins do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/admins&#39;, to: &#39;admins/home#index&#39;, as: :admins

  namespace :umdzes do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/umdzes&#39;, to: &#39;umdzes/home#index&#39;, as: :umdzes

  namespace :patrons do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/patrons&#39;, to: &#39;patrons/home#index&#39;, as: :patrons

  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  get &#39;landing/index&#39;
  root to: &amp;quot;landing#index&amp;quot;
end

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-make-applicationcontrollers-for-each-namespace--enforce-authentication&#34;&gt;now lets make ApplicationControllers for each namespace &amp;amp; enforce authentication&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;touch app/controllers/admins/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/admins/application_controller.rb
class Admins::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_admin!

  private

  def this_user
    current_admin
  end
end
EOF

touch app/controllers/umdzes/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/umdzes/application_controller.rb
class Umdzes::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_umdze!, unless: :allowed_access

  private

  def allowed_access
    current_admin
  end

  def this_user
    current_umdze || current_admin
  end
end
EOF

touch app/controllers/patrons/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/patrons/application_controller.rb
class Patrons::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_patron!, unless: :allowed_access

  private
  def allowed_access
    current_umdze || current_admin
  end

  def this_user
    current_patron || current_umdze || current_admin
  end
end
EOF

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;now-we-will-inhert-from-these-new-controllers-and-enforce-limits&#34;&gt;now we will inhert from these new controllers and enforce limits&lt;/h1&gt;
&lt;p&gt;now lets require these pages to have authenticated the correct user type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/admins/home_controller.rb
class Admins::HomeController &amp;lt; Admins::ApplicationController
  def index
  end
end

# app/controllers/umdzes/home_controller.rb
class Umdzes::HomeController &amp;lt; Umdzes::ApplicationController
  def index
  end
end

# app/controllers/patrons/home_controller.rb
class Patrons::HomeController &amp;lt; Patrons::ApplicationController
  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-prevent-student-and-admin-accounts-from-cross-visits-during-testing-or-whatever&#34;&gt;Now prevent student and admin accounts from cross visits (during testing, or whatever)&lt;/h2&gt;
&lt;p&gt;create this new file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;touch app/controllers/concerns/accessible.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/concerns/accessible.rb
module Accessible
  extend ActiveSupport::Concern
  included do
    before_action :check_user
  end

  protected
  def check_user
    if current_admin
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_admin_root_path) and return
    elsif current_umdze
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_umdze_root_path) and return
    elsif current_patron
      flash.clear
      # The authenticated user root path can be defined in your routes.rb in: devise_scope :user do...
      redirect_to(auth_partron_root_path) and return
    end
  end
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;use-this-accessible-concern&#34;&gt;use this accessible concern&lt;/h2&gt;
&lt;p&gt;Now add &lt;code&gt;include Accessible&lt;/code&gt; in the appropriate controllers:&lt;/p&gt;
&lt;p&gt;Note:
You must skip_before_action for the destroy action in each SessionsController to prevent the redirect to happen before the sign out occurs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# eg. ../controllers/admins/sessions_controller.rb
class Admins::SessionsController &amp;lt; Devise::SessionsController
 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/admins/registrations_controller.rb
You must also skip_before_action for the edit, update, destroy, and cancel actions in each RegistrationsController to allow current users to edit and cancel their own accounts. Otherwise they will be redirected before they can reach these pages.

class Admins::RegistrationsController &amp;lt; Devise::RegistrationsController
 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/umdzes/sessions_controller.rb
class Umdzes::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/umdzes/registrations_controller.rb
class Umdzes::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/patrons/sessions_controller.rb
class Patrons::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/patrons/registrations_controller.rb
class Patrons::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-give-the-patron-account-a-usernames&#34;&gt;now lets give the patron account a usernames&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails generate migration add_username_to_patrons username:string:uniq
rails generate migration add_umdzes_name_to_umdzes fullname:string
rails generate migration add_admins_name_to_admins fullname:string

# now update the new migration to look like:
class AddUsernamToPatrons &amp;lt; ActiveRecord::Migration[6.0]
  def change
    # username is key not email - in fact we don&#39;t want an email
    rename_column :patrons, :email, :username
  end
end

class AddFullnameToUmdzes &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :umdzes, :umdzes_name, :string, null: false
  end
end

class AddFullnameToAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :admins, :admins_name, :string, null: false
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;update-the-models&#34;&gt;update the models&lt;/h2&gt;
&lt;p&gt;now we need to go to the models and make the following updates:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/admin.rb
class Admin &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :admins_name, presence: true
end

# app/models/umdze.rb
class Umdze &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :umdzes_name, presence: true
end


# app/models/patrons.rb
class Patron &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable, # :recoverable
          :authentication_keys =&amp;gt; [:username]

  validates :username, uniqueness: true
  # make the email field optional
  # validates :email, uniqueness: true

  def email_required?
    false
  end

  def email_changed?
    false
  end

  # use this instead of email_changed? for Rails = 5.1.x
  def will_save_change_to_email?
    false
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we can safely migrate &lt;code&gt;bundle exec rails db:migrate&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;lets-test-our-logins&#34;&gt;lets test our logins&lt;/h2&gt;
&lt;p&gt;lets create some common feature test code:&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&lt;/a&gt;

&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/support/features/session_helpers.rb
module Features
  module SessionHelpers
    # def patron_sign_up(username:, password:)
    #   visit new_patron_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Username&#39;, with: username
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def patron_log_in(patron = nil)
      patron = FactoryBot.create :patron if patron.nil?
      visit new_patron_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Username&#39;, with: patron.username
      fill_in &#39;Password&#39;, with: patron.password
      click_on &#39;Log in&#39;
    end

    # def umdze_sign_up(email:, password:)
    #   visit new_umdze_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def umdze_log_in(umdze = nil)
      umdze = FactoryBot.create :umdze if umdze.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end

    # def admin_sign_up(email:, password:)
    #   visit new_admin_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def admin_log_in(admin = nil)
      admin = FactoryBot.create :admin if admin.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are not allowing registrations, so that code is commented out.  However, we see we must configure our factories for this code to work.&lt;/p&gt;
&lt;p&gt;Lets tell rspec how to access this code in feature tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/support/features.rb
RSpec.configure do |config|
  config.include Features::SessionHelpers, type: :feature
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-create-test-for-our-devise-model-factories&#34;&gt;Lets create test for our devise model factories:&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/models/patron_spec.rb
require &#39;rails_helper&#39;

RSpec.describe User, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end

# spec/models/admin_spec.rb
require &#39;rails_helper&#39;

RSpec.describe Admin, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these fail - run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to configure the factories so all is working:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/factories/patrons.rb
FactoryBot.define do
  factory :user do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow&#39; }
    password_confirmation { &#39;LetM3-InNow&#39; }
    # enable this if using confirmable
    # confirmed_at { Date.today }
  end
end

# spec/factories/umdzes.rb
FactoryBot.define do
  factory :umdze do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    umdzes_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

# spec/factories/admins.rb
FactoryBot.define do
  factory :admin do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    admins_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these pass now - run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we are ready to test devise and our restricted access to the users home page:&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.madetech.com/blog/feature-testing-with-rspec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.madetech.com/blog/feature-testing-with-rspec&lt;/a&gt;

&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;

&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&lt;/a&gt;

&lt;a href=&#34;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&lt;/a&gt;

&lt;a href=&#34;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/features/users/user_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  # note user is NOT created in DB!
  let(:user)  { FactoryBot.build :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user is not signed-up&#39; do
    scenario &#39;user signs-up on registration page&#39; do
      user_sign_up(email: user.email, password: user.password)
      expect(current_path).to eql(users_home_path)
    end
  end
end


# spec/features/users/user_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  let(:user)  { FactoryBot.create :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user logs in successfully&#39; do
    scenario &#39;and is redirected to user home page&#39; do
      user_log_in(user)
      expect(current_path).to eql(auth_user_root_path)
    end
  end
end


# spec/features/users_home_page_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  let(:user)    { FactoryBot.create :user }
  after :each do
    # force a logout (clear warden info) after each test
    Warden.test_reset!
  end
  describe &#39;user is not authenticated&#39; do
    scenario &#39;user is redirected to user login before access to user home&#39; do
      visit users_home_path
      expect(current_path).to eql(new_user_session_path)
    end
  end
  describe &#39;user is already authenticated&#39; do
    before    { user_log_in(user) }
    scenario &#39;user gets direct access to the user homepage&#39; do
      visit users_home_path
      expect(page).to have_current_path(users_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and test to be sure admin can log in too:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/features/admins/admin_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  after :each do
    Warden.test_reset!
  end
  scenario &#39;logs in successfully and is redirected to user home page&#39; do
    admin_log_in
    expect(current_path).to eql(auth_admin_root_path)
  end
end


# spec/features/admins/admin_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admin Signup&#39;, type: :feature do
  # IMPORTANT is NOT created in DB!
  let(:admin)  { FactoryBot.build :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;admin is not signed-up&#39; do
    scenario &#39;admin registers&#39; do
      admin_sign_up(email: admin.email, password: admin.password)
      expect(page).to have_current_path(admins_home_path)
    end
  end
end


# spec/features/admins/admins_home_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admins Home&#39;, type: :feature do
  let(:admin)  { FactoryBot.create :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;un-authenticated&#39; do
    scenario &#39;attempts to access admins home page is redirected to user login&#39; do
      visit admins_home_path
      expect(current_path).to eql(new_admin_session_path)
    end
  end
  describe &#39;already authenticated&#39; do
    before    { admin_log_in(admin) }
    scenario &#39;gets access to the user homepage&#39; do
      visit admins_home_path
      expect(current_path).to eql(admins_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;before we wrap up - we need to fix our request specs - now that we added login restrictions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/requests/users/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Patron::Homes&amp;quot;, type: :request do

  let(:patron)   { FactoryBot.create :patron }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;patron_home_path&#39; page is NOT accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in patron
      end
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;patrons_home_path&#39; page is accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/umdze/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Umdze::Homes&amp;quot;, type: :request do
  let(:umdze)   { FactoryBot.create :umdze }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is NOT accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in umdze
      end
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/admins/dashboard_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Admins::Dashboards&amp;quot;, type: :request do

  let(:admin)   { FactoryBot.create :admin }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      it &amp;quot;home as &#39;/admins&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is NOT accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in admin
      end
      after do
        sign_out admin
      end
      it &amp;quot;home as &#39;/admins&#39; page is accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run the tests and be sure all is green - if so, now is a good time to make a commit!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;rspec and devise configured and tests green&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
