<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Devise | btihen</title>
    <link>https://btihen.me/tags/devise/</link>
      <atom:link href="https://btihen.me/tags/devise/index.xml" rel="self" type="application/rss+xml" />
    <description>Devise</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© 2021</copyright><lastBuildDate>Sat, 18 Dec 2021 01:36:55 +0200</lastBuildDate>
    <image>
      <url>https://btihen.me/img/btihen_landing_page.png</url>
      <title>Devise</title>
      <link>https://btihen.me/tags/devise/</link>
    </image>
    
    <item>
      <title>Passwordless Authentication with Devise</title>
      <link>https://btihen.me/post_ruby_rails/rails_6_x_passwordless_devise_w_global_ids/</link>
      <pubDate>Sat, 18 Dec 2021 01:36:55 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/rails_6_x_passwordless_devise_w_global_ids/</guid>
      <description>&lt;p&gt;I wrote a little app for a small non-profit group.  Some of them had severe problems with password management - so this article is how I solved that.&lt;/p&gt;
&lt;p&gt;The easiest way to approach this is to use Rails built-in Secure Global IDs, in this way no database migrations are needed.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;User enters their email-address in a simple form&lt;/li&gt;
&lt;li&gt;If account is found - a link with a token is generated and email is sent&lt;/li&gt;
&lt;li&gt;User is notified that the link is on its way (even if the account is not found and no email is sent)&lt;/li&gt;
&lt;li&gt;When the user follows the link in the email, a session is generated&lt;/li&gt;
&lt;li&gt;Session valid until the session expires or the user logs out (deleting the session).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Since you are using Devise, I will assume you are using it to also manage accounts.  However to keep the code short I will only show what is needed for this one feature.&lt;/p&gt;
&lt;h3 id=&#34;understanding-globalids&#34;&gt;Understanding GlobalIDs&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s start by understanding how Global IDs work&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We start by grabbing a user object and generating a token.&lt;/li&gt;
&lt;li&gt;Next we use the token to retrieve the same user object.
Code to demostrate the usage:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c
user_orig = User.first
# * the `for: &#39;user_auth&#39;` must matching on the receiving end.
# * the `expires_in: 1.hour` can be set for any length of time (default is 30 days)
sgid = user_orig.to_sgid(expires_in: 1.hour, for: &#39;user_auth&#39;)

# now that we have a secured global id, we can generate a token
auth_token = sgid.to_s # token from the Global ID

# should retrieve the user since the token is still valid and the `for:` string matches
user_retrieved = GlobalID::Locator.locate_signed(auth_token, for: &#39;user_auth&#39;)
# try this token again in an hour+ and it should fail!
user_retrieved.id == user_orig.id

# should be nil, since the `for:` string didn&#39;t match
GlobalID::Locator.locate_signed(auth_token, for: &#39;admins_access&#39;).nil?
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;global-ids-for-login&#34;&gt;Global IDs for login&lt;/h3&gt;
&lt;p&gt;To use a Global ID will need a user&amp;rsquo;s email to send it to them and generate a token points to a url that can verify the token and create a session.   So we would need code that looks something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;email = params[:email]
user = User.find_by(email: email)
sgid = user.to_sgid(expires_in: 1.hour, for: &#39;user_auth&#39;)
auth_url = Rails.application.routes.url_helpers
                .auth_user_session_url(auth_token: sgid.to_s)
UserAuthMailer.send_link(user, auth_url).deliver_now
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course we don&amp;rsquo;t have the &lt;code&gt;auth_user_session_url&lt;/code&gt; route and &lt;code&gt;UserAuthMailer.send_link&lt;/code&gt; yet, but we will build that soon.&lt;/p&gt;
&lt;p&gt;To unpack the token and build a session we will need code that looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;auth_token = params[:auth_token]
user = GlobalID::Locator.locate_signed(auth_token, for: &#39;user_auth&#39;)
if user.present?
  sign_in(user) # a devise method
  flash[:notice] = &amp;quot;Welcome back! #{user.email}&amp;quot;
else
  flash[:alert] = &#39;invalid token&#39;
end
redirect_to root_path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets figure out where all this code goes to integrate with both Rails and Devise.&lt;/p&gt;
&lt;h3 id=&#34;simple-app&#34;&gt;Simple App&lt;/h3&gt;
&lt;p&gt;This code-repo is posted at: 
&lt;a href=&#34;https://github.com/btihen/ruby_kafi_passwordless_devise_code&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/btihen/ruby_kafi_passwordless_devise_code&lt;/a&gt; (actually this has code to demo two methods)&lt;/p&gt;
&lt;p&gt;Create a Rails Project&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails new passwordless_devise_code
cd passwordless_devise_code

bin/rails db:create
bin/rails g controller Landing index
bin/rails g scaffold Pet name species
bin/rails db:migrate

## config/routes.rb
Rails.application.routes.draw do
  resources :pets
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The landing page and pets should both be fully available.&lt;/p&gt;
&lt;h3 id=&#34;add-the-devise-gem&#34;&gt;Add the Devise Gem&lt;/h3&gt;
&lt;p&gt;User-Controller to manage users:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle add devise
bundle install
bin/rails generate devise:install
bin/rails generate devise User
# update the migration to match any added features
bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;devise--rails-config-for-email-and-urls&#34;&gt;Devise / Rails Config for email and URLs&lt;/h3&gt;
&lt;p&gt;Devise and Rails need a few config tweeks to do what we want.  (the example is for development, but when publishing of course production will need the appropriate configs too)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/development.rb
self.default_url_options = { host: &#39;http://localhost:3000&#39; }
config.action_mailer.default_url_options = { host: &#39;localhost&#39;, port: 3000 }

# app/views/layouts/application.html.erb
&amp;lt;p class=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;alert&amp;quot;&amp;gt;&amp;lt;%= alert %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;require-authentication-to-access-pets&#34;&gt;Require Authentication to access Pets&lt;/h3&gt;
&lt;p&gt;Now lets activate Devise on all pages, except the landing page.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/application_controller.rb
class ApplicationController &amp;lt; ActionController::Base
  before_action :authenticate_user!
end

# app/controllers/landing_controller.rb
class LandingController &amp;lt; ApplicationController
  skip_before_action :authenticate_user!
  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the landing page should be available, but not the pets page.&lt;/p&gt;
&lt;h3 id=&#34;setup-session-authentication&#34;&gt;Setup Session Authentication&lt;/h3&gt;
&lt;p&gt;We are going to need to generate our own DeviseSession controller and add to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rails g devise:controllers users -c=sessions

# app/controllers/users/sessions_controller.rb:
class Users::SessionsController &amp;lt; Devise::SessionsController
  def auth_token
    auth_token = params[:auth_token]
    user = GlobalID::Locator.locate_signed(auth_token, for: &#39;user_auth&#39;)
    # if we get a user then we know the secured global ID checked out
    if user.present?
      sign_in(user)
      flash[:notice] = &amp;quot;Welcome back! #{user.email}&amp;quot;
      redirect_to pets_path
    else
      flash[:alert] = &#39;OOPS - something went wrong.&#39;
      redirect_to root_path
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to tell Devise and Rails about our new code in the routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#config/routes.rb
Rails.application.routes.draw do
  # tell devise about our sessions controller
  devise_for :users, controllers: { sessions: &#39;users/sessions&#39; }
  devise_scope :user do  # tell rails and devise about our new passwordless authorization route
    get &#39;users/auth_token/:auth_token&#39;, as: :auth_user_session, to: &#39;users/sessions#auth_token&#39;
  end
  resources :pets
  root to: &amp;quot;landing#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we try this now we will get a password error, since devise always assumes a user MUST have and has entered a password.&lt;/p&gt;
&lt;h3 id=&#34;allow-devise-to-ignore-passwords&#34;&gt;Allow Devise to ignore passwords&lt;/h3&gt;
&lt;p&gt;It is tricky to remove the passwords, but easy to ignore them with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord
  before_validation :set_password, on: :create

  # don&#39;t require passwords with user_authenticate!
  def password_required?
    false # because we aren&#39;t using passwords
  end
  private
  # set random Devise passwords to keep devise happy
  def set_password
    tmp_passwd = SecureRandom.alphanumeric(30) # the longer the better (more or less)
    self.password = tmp_passwd
    self.password_confirmation = tmp_passwd
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;testing-our-new-model-and-controller&#34;&gt;Testing our new model and controller&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c

# create new devise user (without a known password)
User.create(email: &amp;quot;tester@test.ch&amp;quot;, name: &amp;quot;Tester&amp;quot;)
user = User.last
sgid = user.to_sgid(expires_in: 1.hour, for: &#39;user_auth&#39;)
auth_url = Rails.application.routes.url_helpers
                .auth_user_session_url(auth_token: sgid.to_s)
#                `auth_user_session_url` - matches our route name we set!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Copy this generated url into your browser and you should end up on the &lt;code&gt;pets&lt;/code&gt; page!&lt;/p&gt;
&lt;h3 id=&#34;emailing-our-auth_token&#34;&gt;Emailing our auth_token&lt;/h3&gt;
&lt;p&gt;Now that we know the Auth Token works, lets learn to email them to the appropriate email&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# create the Emailer code with:
bin/rails g mailer UserAuth send_link

# app/mailers/user_auth_mailer.rb
class UserAuthMailer &amp;lt; ApplicationMailer
  def send_url(user, auth_url)
    @user = user
    @url  = auth_url
    @host = Rails.application.config.hosts.first
    mail to: @user.email, subject: &#39;Sign in into #{@host}&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets create the email contents - let&amp;rsquo;s include a greeting, the sending host and of course the auth_url (we will determine later)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;

# app/views/user_auth_mailer/send_url.html.erb
&amp;lt;p&amp;gt;
  Hi &amp;lt;%= @user.email %&amp;gt;,
  &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
  For access to &amp;lt;%= @host %&amp;gt; &amp;lt;%= link_to &amp;quot;Click here&amp;quot;, @url %&amp;gt;
  &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
  or in plain-text: &amp;lt;%= @url %&amp;gt;
&amp;lt;/p&amp;gt;

# app/views/user_auth_mailer/send_url.text.erb
Hi &amp;lt;%= @user.email %&amp;gt;,

For access to &amp;lt;%= @host %&amp;gt; follow this link:
&amp;lt;%= @url %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;test-the-emailer&#34;&gt;Test the emailer&lt;/h3&gt;
&lt;p&gt;Start mailhog and then:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bin/rails c
user = User.first
sgid = user.to_sgid(expires_in: 1.hour, for: &#39;user_auth&#39;)
auth_url = Rails.application.routes.url_helpers
                .auth_user_session_url(auth_token: sgid.to_s)
UserAuthMailer.send_link(user, auth_url).deliver_now
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now open the mailhog browser tab (or copy the url from the console) and click on the link and pets should open.&lt;/p&gt;
&lt;h3 id=&#34;now-the-hard-devise-strategy-part&#34;&gt;Now the Hard (Devise Strategy) part&lt;/h3&gt;
&lt;p&gt;Now we have all that we need to update Devise with a new Strategy.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mkdir app/lib/devise
mkdir app/lib/devise/models
mkdir app/lib/devise/strategies
touch app/lib/devise/models/token_authenticatable.rb
touch app/lib/devise/strategies/token_authenticatable.rb

# app/lib/devise/models/passwordless_authenticatable.rb
require Rails.root.join(&#39;app/lib/devise/strategies/token_authenticatable&#39;)
module Devise
  module Models
    module TokenAuthenticatable
      extend ActiveSupport::Concern
    end
  end
end

# app/lib/devise/strategies/token_authenticatable.rb
require &#39;devise/strategies/authenticatable&#39;
require_relative &#39;../../../mailers/user_mailer&#39;

module Devise::Strategies
  class TokenAuthenticatable &amp;lt; Authenticatable
    def authenticate!
      email = params.dig(:user, :email)
      user = User.find_by(email: email)
      if user.present? &amp;amp;&amp;amp; !user.locked_at? # and other restrictions as (depending on what was configured)
        auth_sgid = user.to_sgid(expires_in: 1.hour, for: &#39;user_auth&#39;)
        auth_token = auth_sgid.to_s
        auth_url = Rails.application.routes.url_helpers
                        .auth_user_session_url(login_token: auth_token)
        UserAuthMailer.send_url(user, auth_url).deliver_later
      end
      fail!(&amp;quot;An email was sent to you with an authorization link.&amp;quot;)s
    end
  end
end
Warden::Strategies.add(:token_authenticatable, Devise::Strategies::TokenAuthenticatable)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; this strategy authenticates that the user is allowed to get a token.  The &lt;code&gt;auth&lt;/code&gt; method in sessions_controller - authenticates the token and creates a session.&lt;/p&gt;
&lt;h3 id=&#34;tell-devise-to-use-the-new-strategy&#34;&gt;Tell Devise to use the new Strategy&lt;/h3&gt;
&lt;p&gt;Now we want to move Devise away from its default &lt;code&gt;database_athenticable&lt;/code&gt; to &lt;code&gt;token_authenticable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;So now we need to add &lt;code&gt;:token_authenticatable&lt;/code&gt; to our User model:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/users.rb
class User &amp;lt; ApplicationRecord
  before_validation :set_password, on: :create

  # at this point validatable is basically only checking that the email is valid
  devise :token_authenticatable, :validatable

  def password_required?
    false # because we aren&#39;t using passwords
  end
  private
  # since we aren&#39;t using passwords
  def set_password
    tmp_passwd = SecureRandom.alphanumeric(20)
    self.password = tmp_passwd
    self.password_confirmation = tmp_passwd
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, this isn&amp;rsquo;t enough - devise must know to load this strategy at boot - we do this with by adding the following to the VERY TOP of Devise initializer file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/devise.rb
Devise.add_module(:token_authenticatable, {
  strategy:   true,
  route:      :session,
  controller: :sessions,
  model:      &#39;app/lib/devise/models/token_authenticatable&#39;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOTE: if all is good the devise routes should be there (plus our extra one):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;new_user_session      GET     /users/sign_in(.:format)     users/sessions#new
user_session          POST    /users/sign_in(.:format)     users/sessions#create
destroy_user_session  DELETE  /users/sign_out(.:format)    users/sessions#destroy
auth_user_session     GET     /users/auth_token(.:format)  users/sessions#auth_token
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;devise-views-remove-the-passwords&#34;&gt;Devise Views (remove the passwords)&lt;/h3&gt;
&lt;p&gt;Now we need to change the password in the views so we will need to generate the devise views (and configure devise to use scoped views is probably best):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/devise.rb:
config.scoped_views = true

# generate the devise views (to override them)
bin/rails generate devise:views users
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you will need to remove the password field from all the views.  For this project, I will only show the sign_in page:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/views/users/sessions/new.html.erb
&amp;lt;h2&amp;gt;Log in&amp;lt;/h2&amp;gt;
&amp;lt;%= form_for(resource, as: resource_name, url: user_session_path) do |f| %&amp;gt;
  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;%= f.label :email %&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;%= f.email_field :email, autofocus: true, autocomplete: &amp;quot;email&amp;quot; %&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;% if devise_mapping.rememberable? %&amp;gt;
    &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
      &amp;lt;%= f.check_box :remember_me %&amp;gt;
      &amp;lt;%= f.label :remember_me %&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;% end %&amp;gt;
  &amp;lt;div class=&amp;quot;actions&amp;quot;&amp;gt;
    &amp;lt;%= f.submit &amp;quot;Log in&amp;quot; %&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;% end %&amp;gt;
&amp;lt;%= render &amp;quot;users/shared/links&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;security-note&#34;&gt;Security Note&lt;/h3&gt;
&lt;p&gt;NOTE: I prefer a short sgid key life-spans and longer session-lifespans (both are configurable)&lt;/p&gt;
&lt;p&gt;By default rails sessions have no expiration (until logout) and sgids are valid for a month. I find both of these settings too long. To change this default behavior, you can set the session length with the setting:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/session_store.rb
Rails.application.config.session_store :cookie_store, expire_after: 14.days
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you saw in the code where the sgid lifespan is defined.&lt;/p&gt;
&lt;h2 id=&#34;test-the-full-flow&#34;&gt;Test the full flow&lt;/h2&gt;
&lt;p&gt;With all that completed you should be able to test the full workflow!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start rails with: &lt;code&gt;bin/rails s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;start mailhog with: &lt;code&gt;mailhog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to: &lt;code&gt;http://localhost:3000/user/home&lt;/code&gt; (should get redirected to the below URL)&lt;/li&gt;
&lt;li&gt;go to: &lt;code&gt;http://localhost:3000/user/logins&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;enter the &amp;ldquo;
&lt;a href=&#34;mailto:tester@test.ch&#34;&gt;tester@test.ch&lt;/a&gt;&amp;rdquo; email&lt;/li&gt;
&lt;li&gt;Check mailhog for the link &lt;code&gt;http://localhost:8025/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;click the link you should now be on &lt;code&gt;http://localhost:3000/user/home&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Rails GlobalID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The nice thing about these is that the auto expire - simplifying the code a lot.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/rails/globalid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/rails/globalid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.magicalruby.com/implementing-magic-links-in-rails/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.magicalruby.com/implementing-magic-links-in-rails/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Token using SecureRandom&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With these you need to create your own expiration and lookup system (more code add a migration), but will work with any framework.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(using uuids) - 
&lt;a href=&#34;https://oozou.com/blog/how-to-implement-passwordless-authentication-in-ruby-on-rails-154&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://oozou.com/blog/how-to-implement-passwordless-authentication-in-ruby-on-rails-154&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(using SecureRandom) - 
&lt;a href=&#34;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Devise Options&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Devise Plugin - 
&lt;a href=&#34;https://github.com/abevoelker/devise-passwordless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/abevoelker/devise-passwordless&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do it Yourself Devise - 
&lt;a href=&#34;https://dev.to/matiascarpintini/magic-links-with-ruby-on-rails-and-devise-4e3o&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/matiascarpintini/magic-links-with-ruby-on-rails-and-devise-4e3o&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do it yourself Devise - 
&lt;a href=&#34;https://www.mintbit.com/blog/passwordless-authentication-in-ruby-on-rails-with-devise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.mintbit.com/blog/passwordless-authentication-in-ruby-on-rails-with-devise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Other Options&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;passwordless gem - 
&lt;a href=&#34;https://github.com/mikker/passwordless#token-and-session-expiry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/mikker/passwordless#token-and-session-expiry&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;magic-link gem - 
&lt;a href=&#34;https://github.com/dvanderbeek/magic-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/dvanderbeek/magic-link&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using Sorcery - 
&lt;a href=&#34;https://fullstackheroes.com/rails/sorcery-passwordless-authentication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fullstackheroes.com/rails/sorcery-passwordless-authentication/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using Sourcery - 
&lt;a href=&#34;https://www.sitepoint.com/magical-authentication-sorcery/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.sitepoint.com/magical-authentication-sorcery/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(using JWTs) - 
&lt;a href=&#34;https://blog.kiprosh.com/implement-passwordless-authentication-via-magic-link-in-rails-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.kiprosh.com/implement-passwordless-authentication-via-magic-link-in-rails-api/&lt;/a&gt;
&lt;strong&gt;Passwordless Security Overview&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://abevoelker.com/skipping-the-database-with-stateless-tokens-a-hidden-rails-gem-and-a-useful-web-technique/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Sessions&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://blog.saeloun.com/2019/09/12/rails-6-adds-dig-to-actiondispatch-request-session.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.saeloun.com/2019/09/12/rails-6-adds-dig-to-actiondispatch-request-session.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rails Devise User Model with Roles</title>
      <link>https://btihen.me/post_ruby_rails/rails_devise_users_namespaced/</link>
      <pubDate>Fri, 10 Jul 2020 20:45:51 +0200</pubDate>
      <guid>https://btihen.me/post_ruby_rails/rails_devise_users_namespaced/</guid>
      <description>&lt;h2 id=&#34;configure-devise-for-multiple-types-of-accounts&#34;&gt;Configure devise (for multiple types of accounts)&lt;/h2&gt;
&lt;p&gt;install the devise engine:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails generate devise:install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now follow the basic setup config &amp;ndash; add to &lt;code&gt;config/environments/development.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.action_mailer.default_url_options = { host: &#39;localhost&#39;, port: 3000 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add notifications to the layout for devise in &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; just above &lt;code&gt;&amp;lt;%= yeild %&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;lt;p class=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;alert&amp;quot;&amp;gt;&amp;lt;%= alert %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now create one or more models for devise:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails g devise:views
rails generate devise user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update the routes to put the login in separate routes in &lt;code&gt;config/routes.rb&lt;/code&gt; - make the routes look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  devise_for :users,  path: &#39;users&#39;  # http://localhost:3000/users/sign_in
  devise_for :admins, path: &#39;admins&#39; # http://localhost:3000/admins/sign_in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;turn on scoped views (since login forms can be different) in &lt;code&gt;config/initializers/devise.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.scoped_views = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create the scoped views: (instead of: rails g devise:views) do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails g devise:views users/devise
rails g devise:views admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we should open these migrations and uncomment any added fields we use - I generally like to use most of the fields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# frozen_string_literal: true

class DeviseCreateAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    create_table :admins do |t|
      ## Database authenticatable
      t.string :email,              null: false, default: &amp;quot;&amp;quot;
      t.string :encrypted_password, null: false, default: &amp;quot;&amp;quot;

      ## Recoverable
      t.string   :reset_password_token
      t.datetime :reset_password_sent_at

      ## Rememberable
      t.datetime :remember_created_at

      ## Trackable
      t.integer  :sign_in_count, default: 0, null: false
      t.datetime :current_sign_in_at
      t.datetime :last_sign_in_at
      t.inet     :current_sign_in_ip
      t.inet     :last_sign_in_ip

      ## Confirmable
      t.string   :confirmation_token
      t.datetime :confirmed_at
      t.datetime :confirmation_sent_at
      t.string   :unconfirmed_email # Only if using reconfirmable

      ## Lockable
      t.integer  :failed_attempts, default: 0, null: false # Only if lock strategy is :failed_attempts
      t.string   :unlock_token # Only if unlock strategy is :email or :both
      t.datetime :locked_at

      t.timestamps null: false
    end

    add_index :admins, :email,                unique: true
    add_index :admins, :reset_password_token, unique: true
    add_index :admins, :confirmation_token,   unique: true
    add_index :admins, :unlock_token,         unique: true
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and adjust the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;admin&lt;/code&gt; models too and turn on the features we want or need. We will go into detail later, for now I will just add trackable to the models:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable, :trackable,
         :recoverable, :rememberable, :validatable
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and of course migrate too.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create custome controllers for each sessions - this also allows the users to have different fields and features:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails generate devise:controllers users/devise
rails generate devise:controllers admins/devise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;configure the routes to point to these new controllers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # http://localhost:3000/users/sign_in
  devise_for :users,  path: &#39;users&#39;,
                      controllers: {
                        sessions:      &#39;users/devise/sessions&#39;,
                        passwords:     &#39;users/devise/passwords&#39;,
                        registrations: &#39;users/devise/registrations&#39;
                      }
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now the routes should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bin/rails routes
                     Prefix Verb   URI Pattern                        Controller#Action
           new_user_session GET    /users/sign_in(.:format)           users/sessions#new
               user_session POST   /users/sign_in(.:format)           users/sessions#create
       destroy_user_session DELETE /users/sign_out(.:format)          users/sessions#destroy
          new_user_password GET    /users/password/new(.:format)      users/passwords#new
         edit_user_password GET    /users/password/edit(.:format)     users/passwords#edit
              user_password PATCH  /users/password(.:format)          users/passwords#update
                            PUT    /users/password(.:format)          users/passwords#update
                            POST   /users/password(.:format)          users/passwords#create
   cancel_user_registration GET    /users/cancel(.:format)            user/registrations#cancel
      new_user_registration GET    /users/sign_up(.:format)           user/registrations#new
     edit_user_registration GET    /users/edit(.:format)              user/registrations#edit
          user_registration PATCH  /users(.:format)                   user/registrations#update
                            PUT    /users(.:format)                   user/registrations#update
                            DELETE /users(.:format)                   user/registrations#destroy
                            POST   /users(.:format)                   user/registrations#create
          new_admin_session GET    /admins/sign_in(.:format)          admin/sessions#new
              admin_session POST   /admins/sign_in(.:format)          admin/sessions#create
      destroy_admin_session DELETE /admins/sign_out(.:format)         admin/sessions#destroy
         new_admin_password GET    /admins/password/new(.:format)     admin/passwords#new
        edit_admin_password GET    /admins/password/edit(.:format)    admin/passwords#edit
             admin_password PATCH  /admins/password(.:format)         admin/passwords#update
                            PUT    /admins/password(.:format)         admin/passwords#update
                            POST   /admins/password(.:format)         admin/passwords#create
  cancel_admin_registration GET    /admins/cancel(.:format)           admin/registrations#cancel
     new_admin_registration GET    /admins/sign_up(.:format)          admin/registrations#new
    edit_admin_registration GET    /admins/edit(.:format)             admin/registrations#edit
         admin_registration PATCH  /admins(.:format)                  admin/registrations#update
                            PUT    /admins(.:format)                  admin/registrations#update
                            DELETE /admins(.:format)                  admin/registrations#destroy
                            POST   /admins(.:format)                  admin/registrations#create
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lets make logged in home pages (for the user and admin)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails g controller users/home index --no-helper --no-assets --no-controller-specs --no-view-specs
rails g controller admins/home index --no-helper --no-assets --no-controller-specs --no-view-specs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now lets update our routes to ponit to these pages if the user is logged in add the following belos the deivse_for commands&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.routes.draw do
  # http://localhost:3000/admins/sign_in
  devise_for :admins, path: &#39;admins&#39;,
                      controllers: {
                        sessions:      &#39;admins/devise/sessions&#39;,
                        passwords:     &#39;admins/devise/passwords&#39;,
                        registrations: &#39;admins/devise/registrations&#39;
                      }
  # http://localhost:3000/umdzes/sign_in
  devise_for :umdzes, path: &#39;umdzes&#39;,
                      controllers: {
                        sessions:      &#39;umdzes/devise/sessions&#39;,
                        passwords:     &#39;umdzes/devise/passwords&#39;,
                        registrations: &#39;umdzes/devise/registrations&#39;
                      }
  # http://localhost:3000/patrons/sign_in
  devise_for :patrons,  path: &#39;patrons&#39;,
                      controllers: {
                        sessions:      &#39;patrons/devise/sessions&#39;,
                        passwords:     &#39;patrons/devise/passwords&#39;,
                        registrations: &#39;patrons/devise/registrations&#39;
                      }

  authenticated :patron do
    root &#39;patrons/home#index&#39;,     as: :auth_patron_root
  end
  authenticated :umdze do
    root &#39;umdzes/home#index&#39;,      as: :auth_umdze_root
  end
  authenticated :admin do
    root &#39;admins/home#index&#39;, as: :auth_admin_root
  end


  namespace :admins do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/admins&#39;, to: &#39;admins/home#index&#39;, as: :admins

  namespace :umdzes do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/umdzes&#39;, to: &#39;umdzes/home#index&#39;, as: :umdzes

  namespace :patrons do
    get &#39;home/index&#39;
    # resource  :home_page,        only: [:index]
  end
  get &#39;/patrons&#39;, to: &#39;patrons/home#index&#39;, as: :patrons

  get &#39;/landing&#39;, to: &#39;landing#index&#39;, as: :landing
  get &#39;landing/index&#39;
  root to: &amp;quot;landing#index&amp;quot;
end

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-make-applicationcontrollers-for-each-namespace--enforce-authentication&#34;&gt;now lets make ApplicationControllers for each namespace &amp;amp; enforce authentication&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;touch app/controllers/admins/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/admins/application_controller.rb
class Admins::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_admin!

  private

  def this_user
    current_admin
  end
end
EOF

touch app/controllers/umdzes/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/umdzes/application_controller.rb
class Umdzes::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_umdze!, unless: :allowed_access

  private

  def allowed_access
    current_admin
  end

  def this_user
    current_umdze || current_admin
  end
end
EOF

touch app/controllers/patrons/application_controller.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/patrons/application_controller.rb
class Patrons::ApplicationController &amp;lt; ApplicationController
  before_action :authenticate_patron!, unless: :allowed_access

  private
  def allowed_access
    current_umdze || current_admin
  end

  def this_user
    current_patron || current_umdze || current_admin
  end
end
EOF

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;now-we-will-inhert-from-these-new-controllers-and-enforce-limits&#34;&gt;now we will inhert from these new controllers and enforce limits&lt;/h1&gt;
&lt;p&gt;now lets require these pages to have authenticated the correct user type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/admins/home_controller.rb
class Admins::HomeController &amp;lt; Admins::ApplicationController
  def index
  end
end

# app/controllers/umdzes/home_controller.rb
class Umdzes::HomeController &amp;lt; Umdzes::ApplicationController
  def index
  end
end

# app/controllers/patrons/home_controller.rb
class Patrons::HomeController &amp;lt; Patrons::ApplicationController
  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-prevent-student-and-admin-accounts-from-cross-visits-during-testing-or-whatever&#34;&gt;Now prevent student and admin accounts from cross visits (during testing, or whatever)&lt;/h2&gt;
&lt;p&gt;create this new file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;touch app/controllers/concerns/accessible.rb
cat &amp;lt;&amp;lt; EOF &amp;gt; app/controllers/concerns/accessible.rb
module Accessible
  extend ActiveSupport::Concern
  included do
    before_action :check_user
  end

  protected
  def check_user
    if current_admin
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_admin_root_path) and return
    elsif current_umdze
      flash.clear
      # The authenticated admin root path can be defined in your routes.rb in: devise_scope :admin do...
      redirect_to(auth_umdze_root_path) and return
    elsif current_patron
      flash.clear
      # The authenticated user root path can be defined in your routes.rb in: devise_scope :user do...
      redirect_to(auth_partron_root_path) and return
    end
  end
end
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;use-this-accessible-concern&#34;&gt;use this accessible concern&lt;/h2&gt;
&lt;p&gt;Now add &lt;code&gt;include Accessible&lt;/code&gt; in the appropriate controllers:&lt;/p&gt;
&lt;p&gt;Note:
You must skip_before_action for the destroy action in each SessionsController to prevent the redirect to happen before the sign out occurs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# eg. ../controllers/admins/sessions_controller.rb
class Admins::SessionsController &amp;lt; Devise::SessionsController
 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/admins/registrations_controller.rb
You must also skip_before_action for the edit, update, destroy, and cancel actions in each RegistrationsController to allow current users to edit and cancel their own accounts. Otherwise they will be redirected before they can reach these pages.

class Admins::RegistrationsController &amp;lt; Devise::RegistrationsController
 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/umdzes/sessions_controller.rb
class Umdzes::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/umdzes/registrations_controller.rb
class Umdzes::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end

# eg. ../controllers/patrons/sessions_controller.rb
class Patrons::SessionsController &amp;lt; Devise::SessionsController

 include Accessible
 skip_before_action :check_user, only: :destroy
 # ...
end

# eg. ../controllers/patrons/registrations_controller.rb
class Patrons::RegistrationsController &amp;lt; Devise::RegistrationsController

 include Accessible
 skip_before_action :check_user, except: [:new, :create]
 # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;now-lets-give-the-patron-account-a-usernames&#34;&gt;now lets give the patron account a usernames&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To%3A-Allow-users-to-sign-in-with-something-other-than-their-email-address&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails generate migration add_username_to_patrons username:string:uniq
rails generate migration add_umdzes_name_to_umdzes fullname:string
rails generate migration add_admins_name_to_admins fullname:string

# now update the new migration to look like:
class AddUsernamToPatrons &amp;lt; ActiveRecord::Migration[6.0]
  def change
    # username is key not email - in fact we don&#39;t want an email
    rename_column :patrons, :email, :username
  end
end

class AddFullnameToUmdzes &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :umdzes, :umdzes_name, :string, null: false
  end
end

class AddFullnameToAdmins &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_column :admins, :admins_name, :string, null: false
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;update-the-models&#34;&gt;update the models&lt;/h2&gt;
&lt;p&gt;now we need to go to the models and make the following updates:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/admin.rb
class Admin &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :admins_name, presence: true
end

# app/models/umdze.rb
class Umdze &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable #, :recoverable

  validates :email, uniqueness: true
  validates :umdzes_name, presence: true
end


# app/models/patrons.rb
class Patron &amp;lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise  :database_authenticatable, :trackable, # :registerable,
          :rememberable, :validatable, # :recoverable
          :authentication_keys =&amp;gt; [:username]

  validates :username, uniqueness: true
  # make the email field optional
  # validates :email, uniqueness: true

  def email_required?
    false
  end

  def email_changed?
    false
  end

  # use this instead of email_changed? for Rails = 5.1.x
  def will_save_change_to_email?
    false
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now we can safely migrate &lt;code&gt;bundle exec rails db:migrate&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;lets-test-our-logins&#34;&gt;lets test our logins&lt;/h2&gt;
&lt;p&gt;lets create some common feature test code:&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://forum.upcase.com/t/rspec-support-vs-helpers/4986&lt;/a&gt;

&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/support/features/session_helpers.rb
module Features
  module SessionHelpers
    # def patron_sign_up(username:, password:)
    #   visit new_patron_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Username&#39;, with: username
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def patron_log_in(patron = nil)
      patron = FactoryBot.create :patron if patron.nil?
      visit new_patron_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Username&#39;, with: patron.username
      fill_in &#39;Password&#39;, with: patron.password
      click_on &#39;Log in&#39;
    end

    # def umdze_sign_up(email:, password:)
    #   visit new_umdze_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def umdze_log_in(umdze = nil)
      umdze = FactoryBot.create :umdze if umdze.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end

    # def admin_sign_up(email:, password:)
    #   visit new_admin_registration_path
    #   expect(page).to have_button(&#39;Sign up&#39;)
    #   fill_in &#39;Email&#39;, with: email
    #   fill_in &#39;Password&#39;, with: password
    #   click_button &#39;Sign up&#39;
    # end
    def admin_log_in(admin = nil)
      admin = FactoryBot.create :admin if admin.nil?
      visit new_admin_session_path
      expect(page).to have_button(&#39;Log in&#39;)
      fill_in &#39;Email&#39;, with: admin.email
      fill_in &#39;Password&#39;, with: admin.password
      click_on &#39;Log in&#39;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are not allowing registrations, so that code is commented out.  However, we see we must configure our factories for this code to work.&lt;/p&gt;
&lt;p&gt;Lets tell rspec how to access this code in feature tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/support/features.rb
RSpec.configure do |config|
  config.include Features::SessionHelpers, type: :feature
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-create-test-for-our-devise-model-factories&#34;&gt;Lets create test for our devise model factories:&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/models/patron_spec.rb
require &#39;rails_helper&#39;

RSpec.describe User, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid user&amp;quot; do
      model = FactoryBot.build :user
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end

# spec/models/admin_spec.rb
require &#39;rails_helper&#39;

RSpec.describe Admin, type: :model do
  describe &amp;quot;factory functions&amp;quot; do
    it &amp;quot;generates a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.valid?).to be true
    end
    it &amp;quot;saves a valid admin&amp;quot; do
      model = FactoryBot.build :admin
      expect(model.save).to be_truthy
    end
  end

  describe &amp;quot;DB settings&amp;quot; do
    it { have_db_index(:email) }
    it { is_expected.to have_db_column(:encrypted_password) }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these fail - run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to configure the factories so all is working:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/factories/patrons.rb
FactoryBot.define do
  factory :user do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow&#39; }
    password_confirmation { &#39;LetM3-InNow&#39; }
    # enable this if using confirmable
    # confirmed_at { Date.today }
  end
end

# spec/factories/umdzes.rb
FactoryBot.define do
  factory :umdze do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    umdzes_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

# spec/factories/admins.rb
FactoryBot.define do
  factory :admin do
    sequence(:email)      { |n| &amp;quot;#{Faker::Internet.email}&amp;quot;.split(&#39;@&#39;).join(&amp;quot;#{n}@&amp;quot;) }
    password              { &#39;LetM3-InNow!&#39; }
    password_confirmation { &#39;LetM3-InNow!&#39; }
    admins_name           { &amp;quot;#{Faker::Name.first_name} #{Faker::Name.last_name}&amp;quot; }
    # enable this if using confirmable
    # confirmed_at          { Date.today }
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;be sure these pass now - run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rspec spec/models/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we are ready to test devise and our restricted access to the users home page:&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.madetech.com/blog/feature-testing-with-rspec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.madetech.com/blog/feature-testing-with-rspec&lt;/a&gt;

&lt;a href=&#34;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thoughtbot.com/blog/rspec-integration-tests-with-capybara&lt;/a&gt;

&lt;a href=&#34;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/heartcombo/devise/wiki/How-To:-Test-with-Capybara&lt;/a&gt;

&lt;a href=&#34;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://radavis.github.io/sign-in-out-test-helpers-for-and-devise-and-capybara/&lt;/a&gt;

&lt;a href=&#34;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.vanderpol.net/2014/10/07/rspec-integration-tests-devise-user-registration/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/features/users/user_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  # note user is NOT created in DB!
  let(:user)  { FactoryBot.build :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user is not signed-up&#39; do
    scenario &#39;user signs-up on registration page&#39; do
      user_sign_up(email: user.email, password: user.password)
      expect(current_path).to eql(users_home_path)
    end
  end
end


# spec/features/users/user_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  let(:user)  { FactoryBot.create :user }
  after :each do
    Warden.test_reset!
  end
  describe &#39;user logs in successfully&#39; do
    scenario &#39;and is redirected to user home page&#39; do
      user_log_in(user)
      expect(current_path).to eql(auth_user_root_path)
    end
  end
end


# spec/features/users_home_page_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Home Page&#39;, type: :feature do
  let(:user)    { FactoryBot.create :user }
  after :each do
    # force a logout (clear warden info) after each test
    Warden.test_reset!
  end
  describe &#39;user is not authenticated&#39; do
    scenario &#39;user is redirected to user login before access to user home&#39; do
      visit users_home_path
      expect(current_path).to eql(new_user_session_path)
    end
  end
  describe &#39;user is already authenticated&#39; do
    before    { user_log_in(user) }
    scenario &#39;user gets direct access to the user homepage&#39; do
      visit users_home_path
      expect(page).to have_current_path(users_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and test to be sure admin can log in too:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/features/admins/admin_login_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Users Login&#39;, type: :feature do
  after :each do
    Warden.test_reset!
  end
  scenario &#39;logs in successfully and is redirected to user home page&#39; do
    admin_log_in
    expect(current_path).to eql(auth_admin_root_path)
  end
end


# spec/features/admins/admin_signup_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admin Signup&#39;, type: :feature do
  # IMPORTANT is NOT created in DB!
  let(:admin)  { FactoryBot.build :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;admin is not signed-up&#39; do
    scenario &#39;admin registers&#39; do
      admin_sign_up(email: admin.email, password: admin.password)
      expect(page).to have_current_path(admins_home_path)
    end
  end
end


# spec/features/admins/admins_home_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &#39;Admins Home&#39;, type: :feature do
  let(:admin)  { FactoryBot.create :admin }
  after :each do
    Warden.test_reset!
  end
  describe &#39;un-authenticated&#39; do
    scenario &#39;attempts to access admins home page is redirected to user login&#39; do
      visit admins_home_path
      expect(current_path).to eql(new_admin_session_path)
    end
  end
  describe &#39;already authenticated&#39; do
    before    { admin_log_in(admin) }
    scenario &#39;gets access to the user homepage&#39; do
      visit admins_home_path
      expect(current_path).to eql(admins_home_path)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;before we wrap up - we need to fix our request specs - now that we added login restrictions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/requests/users/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Patron::Homes&amp;quot;, type: :request do

  let(:patron)   { FactoryBot.create :patron }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;patron_home_path&#39; page is NOT accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in patron
      end
      after do
        sign_out patron
      end
      it &amp;quot;home as &#39;/patrons&#39; page is accessible&amp;quot; do
        get &amp;quot;/patrons&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;patrons_home_path&#39; page is accessible&amp;quot; do
        get patrons_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_patron_root_path&#39; page is accessible&amp;quot; do
        get auth_patron_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/umdze/home_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Umdze::Homes&amp;quot;, type: :request do
  let(:umdze)   { FactoryBot.create :umdze }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:redirect)
        # to login
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is NOT accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in umdze
      end
      after do
        sign_out umdze
      end
      it &amp;quot;home as &#39;/umdzes&#39; page is accessible&amp;quot; do
        get &amp;quot;/umdzes&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;umdzes_home_path&#39; page is accessible&amp;quot; do
        get umdzes_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_umdze_root_path&#39; page is accessible&amp;quot; do
        get auth_umdze_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end

# spec/requests/admins/dashboard_request_spec.rb
require &#39;rails_helper&#39;

RSpec.describe &amp;quot;Admins::Dashboards&amp;quot;, type: :request do

  let(:admin)   { FactoryBot.create :admin }

  describe &amp;quot;GET /index&amp;quot; do
    context &amp;quot;NOT logged in&amp;quot; do
      it &amp;quot;home as &#39;/admins&#39; page is NOT accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is NOT accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:redirect)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is NOT accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
        # here we need page match for different root routes
      end
    end

    context &amp;quot;logged in&amp;quot; do
      before do
        sign_in admin
      end
      after do
        sign_out admin
      end
      it &amp;quot;home as &#39;/admins&#39; page is accessible&amp;quot; do
        get &amp;quot;/admins&amp;quot;
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;admins_home_path&#39; page is accessible&amp;quot; do
        get admins_home_path
        expect(response).to have_http_status(:success)
      end
      it &amp;quot;home as &#39;auth_admin_root_path&#39; page is accessible&amp;quot; do
        get auth_admin_root_path
        expect(response).to have_http_status(:success)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run the tests and be sure all is green - if so, now is a good time to make a commit!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &amp;quot;rspec and devise configured and tests green&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
