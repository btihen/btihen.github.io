<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lambda | btihen</title>
    <link>http://localhost:1313/tags/lambda/</link>
      <atom:link href="http://localhost:1313/tags/lambda/index.xml" rel="self" type="application/rss+xml" />
    <description>lambda</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© 2021</copyright><lastBuildDate>Sat, 14 Aug 2021 01:11:22 +0200</lastBuildDate>
    <image>
      <url>http://localhost:1313/img/btihen_landing_page.png</url>
      <title>lambda</title>
      <link>http://localhost:1313/tags/lambda/</link>
    </image>
    
    <item>
      <title>Simplify Complex Behavior and Decisions</title>
      <link>http://localhost:1313/post_ruby_rails/rails_6_x_simplify_complex_behavior_decisions/</link>
      <pubDate>Sat, 14 Aug 2021 01:11:22 +0200</pubDate>
      <guid>http://localhost:1313/post_ruby_rails/rails_6_x_simplify_complex_behavior_decisions/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;At work we keep adding features - as our code evolves it tends to fill with lots of conditionals (&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; statements).  Our general rule is all business logic should be in a command and the controller is very simple and just triggers the business logic.&lt;/p&gt;
&lt;h2 id=&#34;recent-situation&#34;&gt;Recent Situation&lt;/h2&gt;
&lt;p&gt;Recently we were extending our billing system.&lt;/p&gt;
&lt;p&gt;All users are grouped by the service they are using and have a billing configuration.&lt;/p&gt;
&lt;p&gt;Our system automatically prints monthly bills for everyone, except those pay automatically (cron triggers a ruby rake task that calls our command object directly).&lt;/p&gt;
&lt;p&gt;That same group of people may have extra charges occasionally sent to all in the group or just a select group of people &amp;ndash; these bills are sent to everyone since they are one-off payments, so they need to go to all people - no matter how they pay their regular bills.  These one off bills are generated by a person (via a rails controller).&lt;/p&gt;
&lt;p&gt;Another time we legally need to send a physical bill to everyone is when the monthly fee changes we.  As you can imagine the selection logic was getting complex and we were sending in more and more parameters to control the logic.&lt;/p&gt;
&lt;p&gt;Our first line of simplification is to extract behaviors out of the controllers and into &lt;code&gt;command objects&lt;/code&gt; (some call these service objects, but we reserve that name for external services).&lt;/p&gt;
&lt;h2 id=&#34;in-the-beginning&#34;&gt;In The Beginning&lt;/h2&gt;
&lt;p&gt;We had a straight-forward setup&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lists other user&#39;s (challenger&#39;s) submissions
class InvoicesController &amp;lt; ApplicationController
  def new
    invoices_form = InvoicesForm.new(invoices_params)
    render :new, locals: {invoices_form: invoices_form}
  end

  def create
    invoices_form = InvoicesForm.new(invoices_params)
    send_invoices = SendInvoicesCommand.new(invoices_form)
    # our commands return a truthy or falsy value
    if invoices_form.valid? &amp;amp;&amp;amp; (result = send_invoices.run) &amp;amp;&amp;amp; result[:success]
      job_id = result[:result]
      redirect_to jobs_path(job_id), success: &amp;quot;Invoices Job Successfully Submitted&amp;quot;
    else
      flash.now[:error] = &amp;quot;Invoices Form / Job has errors&amp;quot;
      render :new, locals: {invoices_form: invoices_form}
    end
  end

  private
  def invoices_params
    params.require(:invoices) .permit(:invoice_id, :group_id, customer_ids: [])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Form Model (without the extras for Rails Validations and forms)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoiceForm
  attr_reader :invoice_form

  # validations

  def new(params)
    @params = params
  end

  def invoice_form
    invoice_form = {}
    # ... whatever is needed to organize and check complex inputs and collect / join multiple models

    invoice_form
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoicesCommand

  def new(invoices_form)
    @invoices_form = invoices_form
  end

  def run
    customer_invoices = InvoiceBuilder.generate_invoices(invoices_form[:customers],
                                                         invoices_form[:time_range])
    send_invoices = customer_invoices.reject { |ci| ci[:customer].ebanking? }  # customers setup knows
    job_id = SendInvoicesJob.call(send_invoices)
    {success: true, result: job_id}
  rescue StandardError =&amp;gt; error
    {success: false, error: error}
  end

  private
  attr_reader :invoices_form
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;getting-complex&#34;&gt;Getting Complex&lt;/h2&gt;
&lt;p&gt;Over time with legal changes and added features our logic was getting complex (even convoluted).&lt;/p&gt;
&lt;p&gt;I find these are easiest to spot when there a lot of if statements - especially when they are controlling the behavior of another object.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoicesCommand

  def new(invoices_form)
    @invoices_form = invoices_form
  end

  def run
    customer_invoices = InvoiceBuilder.generate_invoices(invoices_form)
    send_invoices = if invoices_form[:print_all] &amp;amp;&amp;amp; invoices_form[:customer_ids]
                      customer_invoices.select { |ci| ci[:customer].ebanking? &amp;amp;&amp;amp; !ci[:invoice].monthly? }
                    elsif invoices_form[:customer_ids]
                      customer_invoices.reject { |ci| ci[:customer].ebanking? &amp;amp;&amp;amp; ci[:invoice].monthly? }
                    # ... other user and system choices to filters
                    else
                      customer_invoices.reject { |ci| ci[:customer].ebanking? }  # customers setup knows
                    end
    job_id = SendInvoicesJob.call(send_invoices)
    {success: true, result: job_id}
  rescue StandardError =&amp;gt; error
    {success: false, error: error}
  end

  private
  attr_reader :invoices_form

  def select_invoices_to_send(customer_invoices)
    return customer_invoices if invoices_form[:print_all]   # user wants a print copy for all
    return customer_invoices if invoices_form[:cutomer_ids] # user specifically chose these for
    # ... other user and system choices to filters

    # or just the default filter
    customer_invoices.filter { |ci| !ci[:customer].ebanking? }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;first-attempt---encapsulate-logic-in-a-method&#34;&gt;First Attempt - (encapsulate logic in a method)&lt;/h2&gt;
&lt;p&gt;encapsulate in a method with guards and comments - now the main logic is clear&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoicesCommand

  def new(invoices_form)
    @invoices_form = invoices_form
  end

  def run
    customer_invoices = InvoiceBuilder.generate_invoices(invoices_form)
    send_invoices = select_invoices_to_send(customer_invoices)
    job_id = SendInvoicesJob.call(send_invoices)
    {success: true, result: job_id}
  rescue StandardError =&amp;gt; error
    {success: false, error: error}
  end

  private
  attr_reader :invoices_form

  def select_invoices_to_send(customer_invoices)
    # explain logic
    if invoices_form[:print_all] &amp;amp;&amp;amp; invoices_form[:customer_ids]
      return customer_invoices
    end
    if invoices_form[:customer_ids] # user specifically chose these for
      return customer_invoices.reject { |ci| ci[:invoices].all?(&amp;amp;:monthly?) }
    end

    # ... other user and system choices to filters

    # or do the default filter - send to people without ebanking
    customer_invoices.filter { |ci| !ci[:customer].ebanking? }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;second-attempt---strategy-pattern-traditional&#34;&gt;Second Attempt - Strategy Pattern (Traditional)&lt;/h2&gt;
&lt;p&gt;But then it ocurred to us - why should this object have to sort through all the various inputs and deduce what the user or cron-job wanted to do with the filtering.  So we opted for the strategy pattern and each sender would send the filter pattern wanted.  Also this allows us to name each filter (and clarify intention).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module InvoiceFilter
  # input: customer_invoices = [ {customer: customer, invoice: invoice}, ... ]
  class AllInvoices
    def call(customer_invoices)
      customer_invoices  # no filter - send on alle
    end
  end

  class AllWithoutEbilling
    def call(customer_invoices)
      customer_invoices.filter { |ci| !ci[:customer].ebanking? }
    end
  end

  class AllExceptionalInvoices
    def call(customer_invoices)
      customer_invoices.inject do |ci, result=[]|
        result &amp;lt;&amp;lt; {
                    customer: customer,
                    invoices: invoices.map { |inv| !inv.monthly? }
                  }
        result
      end
    end
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to change the&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoiceForm

  attr_reader :invoice_form

  # validations
  # validates ...

  def new(params)
    @params = params
  end

  def invoice_form
    invoice_form = {}
    # ... whatever is needed
    invoice_form[:filter] = filter_logic

    invoice_form
  end

  private
  def filter_logic
    return InvoiceFilter::AllInvoices.new            if params[:filter] == :all
    return InvoiceFilter::AllExceptionalInvoices.new if params[:filter] == :all_exceptional

    InvoiceFilter::AllWithoutEbilling.new
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoicesCommand

  def new(invoices_form)
    @invoices_form = invoices_form
  end

  def run
    customer_invoices = InvoiceBuilder.generate_invoices(invoices_form)
    invoices = filter_invoices(customer_invoices)
    job_id = SendInvoicesJob.call(invoices)
    {success: true, result: job_id}
  rescue StandardError =&amp;gt; error
    {success: false, error: error}
  end

  private
  attr_reader :invoices_form

  def filter_invoices
    # in-case a strategy isn&#39;t chosen - we set the default strategy
    filter_strategy = invoices_form[:filter] || InvoiceFilter::SelectWithoutEbillingInvoices.new

    filter_strategy.call(customer_invoices)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this design also allows us to send simple lambdas - the form could be rewritten with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoiceForm
  attr_reader :invoice_form

  # validations
  # validates ...

  def new(params)
    @params = params
  end

  def invoice_form
    invoice_form = {}
    # ... whatever is needed
    invoice_form[:filter] = filter_logic

    invoice_form
  end

  private
  def filter_logic
    return InvoiceFilter::AllInvoices.new          if params[:filter] == :all
    return InvoiceFilter::AllExceptionalInvoices.new if params[:filter] == :all_exceptional

    InvoiceFilter::SelectWithoutEbillingInvoices.new
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;third-attempt---simplify-strategy-with-lambdas&#34;&gt;Third Attempt - Simplify Strategy with Lambdas&lt;/h2&gt;
&lt;p&gt;Some filters are very simple we also want to encourage extensions.&lt;/p&gt;
&lt;p&gt;Its also good to note that lambdas are also invoked with .call(), so we transformed the simplest filers into lambdas.&lt;/p&gt;
&lt;p&gt;Lambdas allow you to encapsulate code and assign it a variable name (&amp;amp; pass it around) and invoke it as  convenient.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module InvoiceFilter
  # input: customer_invoices = [ {customer: customer, invoice: invoice}, ... ]

  ALL_INVOICES    = lambda { |customer_invoices| customer_invoices }
  ALL_NO_EBILLING = lambda do |customer_invoices|
                              customer_invoices.filter { |ci| !ci[:customer].ebanking? }
                           end
  class AllExceptionalInvoices
    def call(customer_invoices)
      customer_invoices.inject do |ci, result=[]|
        result &amp;lt;&amp;lt; {
                    customer: customer,
                    invoices: invoices.map { |inv| !inv.monthly? }
                  }
        result
      end
    end
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to change the&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoiceForm

  FILTER_ChOICES = {&#39;all_customer_invoices&#39;     =&amp;gt; InvoiceFilter::ALL_INVOICES,
                    &#39;all_customers_wo_ebilling&#39; =&amp;gt; InvoiceFilter::ALL_NO_EBILLING,
                    &#39;all_exceptional_invoices&#39;  =&amp;gt; InvoiceFilter::AllExceptionalInvoices.new}
  FILTER_KEYS    = FILTER_ChOICES.keys

  attr_reader :invoice_form

  # validations
  # validates ...

  def new(params)
    @params = params
  end

  def invoice_form
    invoice_form = {}
    # ... whatever is needed
    invoice_form[:filter] = filter_logic

    invoice_form
  end

  private
  attr_reader :params

  def validate_filter
    # no choice is valid - we will use the default
    return if params[:filter].blank?
    # a filter (lambda?) sent in by a rake task
    return if params[:filter].responds_to?(:call)
    # a pre-defined filter chosen in the gui
    return if FILTER_KEYS.include?(params[:filter].to_sym)

    errors.add(:filter, &#39;not a valid filter&#39;)
  end

  def filter_logic
    # default filter if no filter is selected
    return InvoiceFilter::ALL_NO_EBILLING  if params[:filter].blank?

    # allow automated internal tasks with access to pass in their own filters
    return params[:filter]                 if params[:filter].responds_to?(:call)

    # did the user select a pre-defined filter available in the GUI
    if params[:filter].is_s? String &amp;amp;&amp;amp; VALID_FILTER_KEYS.include?(filter_symbol)
      return FILTER_CHOICES[filter_symbol]
    end

    # this shouldn&#39;t happen if validated before running
    raise &#39;filter error&#39;
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvoicesCommand

  def new(invoices_form)
    @invoices_form = invoices_form
  end

  def run
    customer_invoices = InvoiceBuilder.generate_invoices(invoices_form)
    invoices = filter_invoices(customer_invoices)
    job_id = SendInvoicesJob.call(invoices)
    {success: true, result: job_id}
  rescue StandardError =&amp;gt; error
    {success: false, error: error}
  end

  private
  attr_reader :invoices_form

  def filter_invoices
    # in-case a strategy isn&#39;t chosen - we set the default strategy
    filter_strategy = invoices_form[:filter] || InvoiceFilter::SelectWithoutEbillingInvoices.new

    filter_strategy.call(customer_invoices)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;STRATEGY VS COMMAND PATTERN&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/4834979/difference-between-strategy-pattern-and-command-pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://stackoverflow.com/questions/4834979/difference-between-strategy-pattern-and-command-pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://newbedev.com/using-a-strategy-pattern-and-a-command-pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://newbedev.com/using-a-strategy-pattern-and-a-command-pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://miafish.wordpress.com/2015/01/16/command-pattern-vs-strategy-pattern/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://miafish.wordpress.com/2015/01/16/command-pattern-vs-strategy-pattern/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://coderanch.com/t/100214/engineering/Command-Strategy-Pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://coderanch.com/t/100214/engineering/Command-Strategy-Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;STRATEGY&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://dockyard.com/blog/2013/07/25/design-patterns-strategy-pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dockyard.com/blog/2013/07/25/design-patterns-strategy-pattern&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://wickedlysmart.com/using-lambda-expressions-with-the-strategy-pattern/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://wickedlysmart.com/using-lambda-expressions-with-the-strategy-pattern/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://blog.sebastian-daschner.com/entries/strategy-pattern-cdi-lambdas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.sebastian-daschner.com/entries/strategy-pattern-cdi-lambdas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://refactoring.guru/design-patterns/strategy/ruby/example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://refactoring.guru/design-patterns/strategy/ruby/example&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://rubyblog.pro/2016/10/ruby-strategy-pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://rubyblog.pro/2016/10/ruby-strategy-pattern&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://dev.to/andyobtiva/strategic-e9i&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/andyobtiva/strategic-e9i&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/AndyObtiva/strategic&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/AndyObtiva/strategic&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://andymaleh.blogspot.com/2021/03/strategic-091-strategy.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://andymaleh.blogspot.com/2021/03/strategic-091-strategy.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;COMMAND&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.sihui.io/design-pattern-command/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.sihui.io/design-pattern-command/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://rubypatterns.dev/general/command.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://rubypatterns.dev/general/command.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://dockyard.com/blog/2013/11/05/design-patterns-command-pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dockyard.com/blog/2013/11/05/design-patterns-command-pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://jobandtalent.engineering/command-pattern-how-and-why-we-use-it-fa8af952bca1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://jobandtalent.engineering/command-pattern-how-and-why-we-use-it-fa8af952bca1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://blog.appsignal.com/2021/04/14/ruby-on-rails-controller-patterns-and-anti-patterns.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.appsignal.com/2021/04/14/ruby-on-rails-controller-patterns-and-anti-patterns.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://metalelf0.github.io/rails/2016/05/02/command-pattern.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://metalelf0.github.io/rails/2016/05/02/command-pattern.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LAMBDA&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://scoutapm.com/blog/how-to-use-lambdas-in-ruby&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://scoutapm.com/blog/how-to-use-lambdas-in-ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://sodocumentation.net/ruby/topic/474/blocks-and-procs-and-lambdas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://sodocumentation.net/ruby/topic/474/blocks-and-procs-and-lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.freecodecamp.org/news/design-patterns-command-and-concierge-in-life-and-ruby-aab9815817ea/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.freecodecamp.org/news/design-patterns-command-and-concierge-in-life-and-ruby-aab9815817ea/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Decorator

&lt;a href=&#34;https://www.rootstrap.com/blog/how-to-improve-maintainability-in-rails-applications-using-patterns/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.rootstrap.com/blog/how-to-improve-maintainability-in-rails-applications-using-patterns/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://goiabada.blog/interactors-in-ruby-easy-as-cake-simple-as-pie-33f66de2eb78&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://goiabada.blog/interactors-in-ruby-easy-as-cake-simple-as-pie-33f66de2eb78&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://refactoring.guru/design-patterns/command/ruby/example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://refactoring.guru/design-patterns/command/ruby/example&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://agprolink.asfmra.org/HigherLogic/System/DownloadDocumentFile.ashx?DocumentFileKey=71b7446e-6c64-3974-bb9e-0ff0a0cf8305&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://agprolink.asfmra.org/HigherLogic/System/DownloadDocumentFile.ashx?DocumentFileKey=71b7446e-6c64-3974-bb9e-0ff0a0cf8305&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://makandracards.com/alexander-m/43748-command-pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://makandracards.com/alexander-m/43748-command-pattern&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://medium.com/@dljerome/design-patterns-in-ruby-command-802b785d1bbd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://medium.com/@dljerome/design-patterns-in-ruby-command-802b785d1bbd&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://medium.com/@ibell/the-ruby-command-pattern-pt-1-ad6711af0722&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://medium.com/@ibell/the-ruby-command-pattern-pt-1-ad6711af0722&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/43535421/command-pattern-in-ruby&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://stackoverflow.com/questions/43535421/command-pattern-in-ruby&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/davidgf/design-patterns-in-ruby/blob/master/command.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/davidgf/design-patterns-in-ruby/blob/master/command.md&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://scoutapm.com/blog/how-to-use-lambdas-in-ruby&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://scoutapm.com/blog/how-to-use-lambdas-in-ruby&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/43535421/command-pattern-in-ruby&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://stackoverflow.com/questions/43535421/command-pattern-in-ruby&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://medium.com/@nakshtra17/ruby-design-pattern-command-method-3d1e3f41d39d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://medium.com/@nakshtra17/ruby-design-pattern-command-method-3d1e3f41d39d&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://journal.stuffwithstuff.com/2009/07/02/closures-and-the-command-pattern/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://journal.stuffwithstuff.com/2009/07/02/closures-and-the-command-pattern/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://radar.oreilly.com/2014/12/using-the-command-pattern-with-lambda-expressions.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://radar.oreilly.com/2014/12/using-the-command-pattern-with-lambda-expressions.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/piscolomo/ruby-patterns/blob/master/command.rb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/piscolomo/ruby-patterns/blob/master/command.rb&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Command_pattern&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://en.wikipedia.org/wiki/Command_pattern&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://sodocumentation.net/ruby/topic/474/blocks-and-procs-and-lambdas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://sodocumentation.net/ruby/topic/474/blocks-and-procs-and-lambdas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.freecodecamp.org/news/the-basic-design-patterns-all-developers-need-to-know/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.freecodecamp.org/news/the-basic-design-patterns-all-developers-need-to-know/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.developer.com/java/understanding-lambda-enabled-design-patterns/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.developer.com/java/understanding-lambda-enabled-design-patterns/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
